// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package study

import (
	"context"
	"github.com/google/uuid"
	"github.com/heartmarshall/myenglish-backend/internal/domain"
	"sync"
	"time"
)

// Ensure, that cardRepoMock does implement cardRepo.
// If this is not the case, regenerate this file with moq.
var _ cardRepo = &cardRepoMock{}

// cardRepoMock is a mock implementation of cardRepo.
//
//	func TestSomethingThatUsescardRepo(t *testing.T) {
//
//		// make and configure a mocked cardRepo
//		mockedcardRepo := &cardRepoMock{
//			CountByStatusFunc: func(ctx context.Context, userID uuid.UUID) (domain.CardStatusCounts, error) {
//				panic("mock out the CountByStatus method")
//			},
//			CountDueFunc: func(ctx context.Context, userID uuid.UUID, now time.Time) (int, error) {
//				panic("mock out the CountDue method")
//			},
//			CountNewFunc: func(ctx context.Context, userID uuid.UUID) (int, error) {
//				panic("mock out the CountNew method")
//			},
//			CreateFunc: func(ctx context.Context, userID uuid.UUID, card *domain.Card) (*domain.Card, error) {
//				panic("mock out the Create method")
//			},
//			DeleteFunc: func(ctx context.Context, userID uuid.UUID, cardID uuid.UUID) error {
//				panic("mock out the Delete method")
//			},
//			ExistsByEntryIDsFunc: func(ctx context.Context, userID uuid.UUID, entryIDs []uuid.UUID) (map[uuid.UUID]bool, error) {
//				panic("mock out the ExistsByEntryIDs method")
//			},
//			GetByEntryIDFunc: func(ctx context.Context, userID uuid.UUID, entryID uuid.UUID) (*domain.Card, error) {
//				panic("mock out the GetByEntryID method")
//			},
//			GetByIDFunc: func(ctx context.Context, userID uuid.UUID, cardID uuid.UUID) (*domain.Card, error) {
//				panic("mock out the GetByID method")
//			},
//			GetDueCardsFunc: func(ctx context.Context, userID uuid.UUID, now time.Time, limit int) ([]*domain.Card, error) {
//				panic("mock out the GetDueCards method")
//			},
//			GetNewCardsFunc: func(ctx context.Context, userID uuid.UUID, limit int) ([]*domain.Card, error) {
//				panic("mock out the GetNewCards method")
//			},
//			UpdateSRSFunc: func(ctx context.Context, userID uuid.UUID, cardID uuid.UUID, params domain.SRSUpdateParams) (*domain.Card, error) {
//				panic("mock out the UpdateSRS method")
//			},
//		}
//
//		// use mockedcardRepo in code that requires cardRepo
//		// and then make assertions.
//
//	}
type cardRepoMock struct {
	// CountByStatusFunc mocks the CountByStatus method.
	CountByStatusFunc func(ctx context.Context, userID uuid.UUID) (domain.CardStatusCounts, error)

	// CountDueFunc mocks the CountDue method.
	CountDueFunc func(ctx context.Context, userID uuid.UUID, now time.Time) (int, error)

	// CountNewFunc mocks the CountNew method.
	CountNewFunc func(ctx context.Context, userID uuid.UUID) (int, error)

	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, userID uuid.UUID, card *domain.Card) (*domain.Card, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, userID uuid.UUID, cardID uuid.UUID) error

	// ExistsByEntryIDsFunc mocks the ExistsByEntryIDs method.
	ExistsByEntryIDsFunc func(ctx context.Context, userID uuid.UUID, entryIDs []uuid.UUID) (map[uuid.UUID]bool, error)

	// GetByEntryIDFunc mocks the GetByEntryID method.
	GetByEntryIDFunc func(ctx context.Context, userID uuid.UUID, entryID uuid.UUID) (*domain.Card, error)

	// GetByIDFunc mocks the GetByID method.
	GetByIDFunc func(ctx context.Context, userID uuid.UUID, cardID uuid.UUID) (*domain.Card, error)

	// GetDueCardsFunc mocks the GetDueCards method.
	GetDueCardsFunc func(ctx context.Context, userID uuid.UUID, now time.Time, limit int) ([]*domain.Card, error)

	// GetNewCardsFunc mocks the GetNewCards method.
	GetNewCardsFunc func(ctx context.Context, userID uuid.UUID, limit int) ([]*domain.Card, error)

	// UpdateSRSFunc mocks the UpdateSRS method.
	UpdateSRSFunc func(ctx context.Context, userID uuid.UUID, cardID uuid.UUID, params domain.SRSUpdateParams) (*domain.Card, error)

	// calls tracks calls to the methods.
	calls struct {
		// CountByStatus holds details about calls to the CountByStatus method.
		CountByStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
		}
		// CountDue holds details about calls to the CountDue method.
		CountDue []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// Now is the now argument value.
			Now time.Time
		}
		// CountNew holds details about calls to the CountNew method.
		CountNew []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
		}
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// Card is the card argument value.
			Card *domain.Card
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// CardID is the cardID argument value.
			CardID uuid.UUID
		}
		// ExistsByEntryIDs holds details about calls to the ExistsByEntryIDs method.
		ExistsByEntryIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// EntryIDs is the entryIDs argument value.
			EntryIDs []uuid.UUID
		}
		// GetByEntryID holds details about calls to the GetByEntryID method.
		GetByEntryID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// EntryID is the entryID argument value.
			EntryID uuid.UUID
		}
		// GetByID holds details about calls to the GetByID method.
		GetByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// CardID is the cardID argument value.
			CardID uuid.UUID
		}
		// GetDueCards holds details about calls to the GetDueCards method.
		GetDueCards []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// Now is the now argument value.
			Now time.Time
			// Limit is the limit argument value.
			Limit int
		}
		// GetNewCards holds details about calls to the GetNewCards method.
		GetNewCards []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// Limit is the limit argument value.
			Limit int
		}
		// UpdateSRS holds details about calls to the UpdateSRS method.
		UpdateSRS []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// CardID is the cardID argument value.
			CardID uuid.UUID
			// Params is the params argument value.
			Params domain.SRSUpdateParams
		}
	}
	lockCountByStatus    sync.RWMutex
	lockCountDue         sync.RWMutex
	lockCountNew         sync.RWMutex
	lockCreate           sync.RWMutex
	lockDelete           sync.RWMutex
	lockExistsByEntryIDs sync.RWMutex
	lockGetByEntryID     sync.RWMutex
	lockGetByID          sync.RWMutex
	lockGetDueCards      sync.RWMutex
	lockGetNewCards      sync.RWMutex
	lockUpdateSRS        sync.RWMutex
}

// CountByStatus calls CountByStatusFunc.
func (mock *cardRepoMock) CountByStatus(ctx context.Context, userID uuid.UUID) (domain.CardStatusCounts, error) {
	if mock.CountByStatusFunc == nil {
		panic("cardRepoMock.CountByStatusFunc: method is nil but cardRepo.CountByStatus was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockCountByStatus.Lock()
	mock.calls.CountByStatus = append(mock.calls.CountByStatus, callInfo)
	mock.lockCountByStatus.Unlock()
	return mock.CountByStatusFunc(ctx, userID)
}

// CountByStatusCalls gets all the calls that were made to CountByStatus.
// Check the length with:
//
//	len(mockedcardRepo.CountByStatusCalls())
func (mock *cardRepoMock) CountByStatusCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
	}
	mock.lockCountByStatus.RLock()
	calls = mock.calls.CountByStatus
	mock.lockCountByStatus.RUnlock()
	return calls
}

// CountDue calls CountDueFunc.
func (mock *cardRepoMock) CountDue(ctx context.Context, userID uuid.UUID, now time.Time) (int, error) {
	if mock.CountDueFunc == nil {
		panic("cardRepoMock.CountDueFunc: method is nil but cardRepo.CountDue was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
		Now    time.Time
	}{
		Ctx:    ctx,
		UserID: userID,
		Now:    now,
	}
	mock.lockCountDue.Lock()
	mock.calls.CountDue = append(mock.calls.CountDue, callInfo)
	mock.lockCountDue.Unlock()
	return mock.CountDueFunc(ctx, userID, now)
}

// CountDueCalls gets all the calls that were made to CountDue.
// Check the length with:
//
//	len(mockedcardRepo.CountDueCalls())
func (mock *cardRepoMock) CountDueCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
	Now    time.Time
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
		Now    time.Time
	}
	mock.lockCountDue.RLock()
	calls = mock.calls.CountDue
	mock.lockCountDue.RUnlock()
	return calls
}

// CountNew calls CountNewFunc.
func (mock *cardRepoMock) CountNew(ctx context.Context, userID uuid.UUID) (int, error) {
	if mock.CountNewFunc == nil {
		panic("cardRepoMock.CountNewFunc: method is nil but cardRepo.CountNew was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockCountNew.Lock()
	mock.calls.CountNew = append(mock.calls.CountNew, callInfo)
	mock.lockCountNew.Unlock()
	return mock.CountNewFunc(ctx, userID)
}

// CountNewCalls gets all the calls that were made to CountNew.
// Check the length with:
//
//	len(mockedcardRepo.CountNewCalls())
func (mock *cardRepoMock) CountNewCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
	}
	mock.lockCountNew.RLock()
	calls = mock.calls.CountNew
	mock.lockCountNew.RUnlock()
	return calls
}

// Create calls CreateFunc.
func (mock *cardRepoMock) Create(ctx context.Context, userID uuid.UUID, card *domain.Card) (*domain.Card, error) {
	if mock.CreateFunc == nil {
		panic("cardRepoMock.CreateFunc: method is nil but cardRepo.Create was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
		Card   *domain.Card
	}{
		Ctx:    ctx,
		UserID: userID,
		Card:   card,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, userID, card)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedcardRepo.CreateCalls())
func (mock *cardRepoMock) CreateCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
	Card   *domain.Card
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
		Card   *domain.Card
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *cardRepoMock) Delete(ctx context.Context, userID uuid.UUID, cardID uuid.UUID) error {
	if mock.DeleteFunc == nil {
		panic("cardRepoMock.DeleteFunc: method is nil but cardRepo.Delete was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
		CardID uuid.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
		CardID: cardID,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, userID, cardID)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedcardRepo.DeleteCalls())
func (mock *cardRepoMock) DeleteCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
	CardID uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
		CardID uuid.UUID
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// ExistsByEntryIDs calls ExistsByEntryIDsFunc.
func (mock *cardRepoMock) ExistsByEntryIDs(ctx context.Context, userID uuid.UUID, entryIDs []uuid.UUID) (map[uuid.UUID]bool, error) {
	if mock.ExistsByEntryIDsFunc == nil {
		panic("cardRepoMock.ExistsByEntryIDsFunc: method is nil but cardRepo.ExistsByEntryIDs was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		UserID   uuid.UUID
		EntryIDs []uuid.UUID
	}{
		Ctx:      ctx,
		UserID:   userID,
		EntryIDs: entryIDs,
	}
	mock.lockExistsByEntryIDs.Lock()
	mock.calls.ExistsByEntryIDs = append(mock.calls.ExistsByEntryIDs, callInfo)
	mock.lockExistsByEntryIDs.Unlock()
	return mock.ExistsByEntryIDsFunc(ctx, userID, entryIDs)
}

// ExistsByEntryIDsCalls gets all the calls that were made to ExistsByEntryIDs.
// Check the length with:
//
//	len(mockedcardRepo.ExistsByEntryIDsCalls())
func (mock *cardRepoMock) ExistsByEntryIDsCalls() []struct {
	Ctx      context.Context
	UserID   uuid.UUID
	EntryIDs []uuid.UUID
} {
	var calls []struct {
		Ctx      context.Context
		UserID   uuid.UUID
		EntryIDs []uuid.UUID
	}
	mock.lockExistsByEntryIDs.RLock()
	calls = mock.calls.ExistsByEntryIDs
	mock.lockExistsByEntryIDs.RUnlock()
	return calls
}

// GetByEntryID calls GetByEntryIDFunc.
func (mock *cardRepoMock) GetByEntryID(ctx context.Context, userID uuid.UUID, entryID uuid.UUID) (*domain.Card, error) {
	if mock.GetByEntryIDFunc == nil {
		panic("cardRepoMock.GetByEntryIDFunc: method is nil but cardRepo.GetByEntryID was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		UserID  uuid.UUID
		EntryID uuid.UUID
	}{
		Ctx:     ctx,
		UserID:  userID,
		EntryID: entryID,
	}
	mock.lockGetByEntryID.Lock()
	mock.calls.GetByEntryID = append(mock.calls.GetByEntryID, callInfo)
	mock.lockGetByEntryID.Unlock()
	return mock.GetByEntryIDFunc(ctx, userID, entryID)
}

// GetByEntryIDCalls gets all the calls that were made to GetByEntryID.
// Check the length with:
//
//	len(mockedcardRepo.GetByEntryIDCalls())
func (mock *cardRepoMock) GetByEntryIDCalls() []struct {
	Ctx     context.Context
	UserID  uuid.UUID
	EntryID uuid.UUID
} {
	var calls []struct {
		Ctx     context.Context
		UserID  uuid.UUID
		EntryID uuid.UUID
	}
	mock.lockGetByEntryID.RLock()
	calls = mock.calls.GetByEntryID
	mock.lockGetByEntryID.RUnlock()
	return calls
}

// GetByID calls GetByIDFunc.
func (mock *cardRepoMock) GetByID(ctx context.Context, userID uuid.UUID, cardID uuid.UUID) (*domain.Card, error) {
	if mock.GetByIDFunc == nil {
		panic("cardRepoMock.GetByIDFunc: method is nil but cardRepo.GetByID was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
		CardID uuid.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
		CardID: cardID,
	}
	mock.lockGetByID.Lock()
	mock.calls.GetByID = append(mock.calls.GetByID, callInfo)
	mock.lockGetByID.Unlock()
	return mock.GetByIDFunc(ctx, userID, cardID)
}

// GetByIDCalls gets all the calls that were made to GetByID.
// Check the length with:
//
//	len(mockedcardRepo.GetByIDCalls())
func (mock *cardRepoMock) GetByIDCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
	CardID uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
		CardID uuid.UUID
	}
	mock.lockGetByID.RLock()
	calls = mock.calls.GetByID
	mock.lockGetByID.RUnlock()
	return calls
}

// GetDueCards calls GetDueCardsFunc.
func (mock *cardRepoMock) GetDueCards(ctx context.Context, userID uuid.UUID, now time.Time, limit int) ([]*domain.Card, error) {
	if mock.GetDueCardsFunc == nil {
		panic("cardRepoMock.GetDueCardsFunc: method is nil but cardRepo.GetDueCards was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
		Now    time.Time
		Limit  int
	}{
		Ctx:    ctx,
		UserID: userID,
		Now:    now,
		Limit:  limit,
	}
	mock.lockGetDueCards.Lock()
	mock.calls.GetDueCards = append(mock.calls.GetDueCards, callInfo)
	mock.lockGetDueCards.Unlock()
	return mock.GetDueCardsFunc(ctx, userID, now, limit)
}

// GetDueCardsCalls gets all the calls that were made to GetDueCards.
// Check the length with:
//
//	len(mockedcardRepo.GetDueCardsCalls())
func (mock *cardRepoMock) GetDueCardsCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
	Now    time.Time
	Limit  int
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
		Now    time.Time
		Limit  int
	}
	mock.lockGetDueCards.RLock()
	calls = mock.calls.GetDueCards
	mock.lockGetDueCards.RUnlock()
	return calls
}

// GetNewCards calls GetNewCardsFunc.
func (mock *cardRepoMock) GetNewCards(ctx context.Context, userID uuid.UUID, limit int) ([]*domain.Card, error) {
	if mock.GetNewCardsFunc == nil {
		panic("cardRepoMock.GetNewCardsFunc: method is nil but cardRepo.GetNewCards was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
		Limit  int
	}{
		Ctx:    ctx,
		UserID: userID,
		Limit:  limit,
	}
	mock.lockGetNewCards.Lock()
	mock.calls.GetNewCards = append(mock.calls.GetNewCards, callInfo)
	mock.lockGetNewCards.Unlock()
	return mock.GetNewCardsFunc(ctx, userID, limit)
}

// GetNewCardsCalls gets all the calls that were made to GetNewCards.
// Check the length with:
//
//	len(mockedcardRepo.GetNewCardsCalls())
func (mock *cardRepoMock) GetNewCardsCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
	Limit  int
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
		Limit  int
	}
	mock.lockGetNewCards.RLock()
	calls = mock.calls.GetNewCards
	mock.lockGetNewCards.RUnlock()
	return calls
}

// UpdateSRS calls UpdateSRSFunc.
func (mock *cardRepoMock) UpdateSRS(ctx context.Context, userID uuid.UUID, cardID uuid.UUID, params domain.SRSUpdateParams) (*domain.Card, error) {
	if mock.UpdateSRSFunc == nil {
		panic("cardRepoMock.UpdateSRSFunc: method is nil but cardRepo.UpdateSRS was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
		CardID uuid.UUID
		Params domain.SRSUpdateParams
	}{
		Ctx:    ctx,
		UserID: userID,
		CardID: cardID,
		Params: params,
	}
	mock.lockUpdateSRS.Lock()
	mock.calls.UpdateSRS = append(mock.calls.UpdateSRS, callInfo)
	mock.lockUpdateSRS.Unlock()
	return mock.UpdateSRSFunc(ctx, userID, cardID, params)
}

// UpdateSRSCalls gets all the calls that were made to UpdateSRS.
// Check the length with:
//
//	len(mockedcardRepo.UpdateSRSCalls())
func (mock *cardRepoMock) UpdateSRSCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
	CardID uuid.UUID
	Params domain.SRSUpdateParams
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
		CardID uuid.UUID
		Params domain.SRSUpdateParams
	}
	mock.lockUpdateSRS.RLock()
	calls = mock.calls.UpdateSRS
	mock.lockUpdateSRS.RUnlock()
	return calls
}

// Ensure, that reviewLogRepoMock does implement reviewLogRepo.
// If this is not the case, regenerate this file with moq.
var _ reviewLogRepo = &reviewLogRepoMock{}

// reviewLogRepoMock is a mock implementation of reviewLogRepo.
//
//	func TestSomethingThatUsesreviewLogRepo(t *testing.T) {
//
//		// make and configure a mocked reviewLogRepo
//		mockedreviewLogRepo := &reviewLogRepoMock{
//			CountNewTodayFunc: func(ctx context.Context, userID uuid.UUID, dayStart time.Time) (int, error) {
//				panic("mock out the CountNewToday method")
//			},
//			CountTodayFunc: func(ctx context.Context, userID uuid.UUID, dayStart time.Time) (int, error) {
//				panic("mock out the CountToday method")
//			},
//			CreateFunc: func(ctx context.Context, log *domain.ReviewLog) (*domain.ReviewLog, error) {
//				panic("mock out the Create method")
//			},
//			DeleteFunc: func(ctx context.Context, id uuid.UUID) error {
//				panic("mock out the Delete method")
//			},
//			GetByCardIDFunc: func(ctx context.Context, cardID uuid.UUID, limit int, offset int) ([]*domain.ReviewLog, int, error) {
//				panic("mock out the GetByCardID method")
//			},
//			GetByPeriodFunc: func(ctx context.Context, userID uuid.UUID, from time.Time, to time.Time) ([]*domain.ReviewLog, error) {
//				panic("mock out the GetByPeriod method")
//			},
//			GetLastByCardIDFunc: func(ctx context.Context, cardID uuid.UUID) (*domain.ReviewLog, error) {
//				panic("mock out the GetLastByCardID method")
//			},
//			GetStreakDaysFunc: func(ctx context.Context, userID uuid.UUID, dayStart time.Time, lastNDays int) ([]domain.DayReviewCount, error) {
//				panic("mock out the GetStreakDays method")
//			},
//		}
//
//		// use mockedreviewLogRepo in code that requires reviewLogRepo
//		// and then make assertions.
//
//	}
type reviewLogRepoMock struct {
	// CountNewTodayFunc mocks the CountNewToday method.
	CountNewTodayFunc func(ctx context.Context, userID uuid.UUID, dayStart time.Time) (int, error)

	// CountTodayFunc mocks the CountToday method.
	CountTodayFunc func(ctx context.Context, userID uuid.UUID, dayStart time.Time) (int, error)

	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, log *domain.ReviewLog) (*domain.ReviewLog, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, id uuid.UUID) error

	// GetByCardIDFunc mocks the GetByCardID method.
	GetByCardIDFunc func(ctx context.Context, cardID uuid.UUID, limit int, offset int) ([]*domain.ReviewLog, int, error)

	// GetByPeriodFunc mocks the GetByPeriod method.
	GetByPeriodFunc func(ctx context.Context, userID uuid.UUID, from time.Time, to time.Time) ([]*domain.ReviewLog, error)

	// GetLastByCardIDFunc mocks the GetLastByCardID method.
	GetLastByCardIDFunc func(ctx context.Context, cardID uuid.UUID) (*domain.ReviewLog, error)

	// GetStreakDaysFunc mocks the GetStreakDays method.
	GetStreakDaysFunc func(ctx context.Context, userID uuid.UUID, dayStart time.Time, lastNDays int) ([]domain.DayReviewCount, error)

	// calls tracks calls to the methods.
	calls struct {
		// CountNewToday holds details about calls to the CountNewToday method.
		CountNewToday []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// DayStart is the dayStart argument value.
			DayStart time.Time
		}
		// CountToday holds details about calls to the CountToday method.
		CountToday []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// DayStart is the dayStart argument value.
			DayStart time.Time
		}
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Log is the log argument value.
			Log *domain.ReviewLog
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// GetByCardID holds details about calls to the GetByCardID method.
		GetByCardID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CardID is the cardID argument value.
			CardID uuid.UUID
			// Limit is the limit argument value.
			Limit int
			// Offset is the offset argument value.
			Offset int
		}
		// GetByPeriod holds details about calls to the GetByPeriod method.
		GetByPeriod []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// From is the from argument value.
			From time.Time
			// To is the to argument value.
			To time.Time
		}
		// GetLastByCardID holds details about calls to the GetLastByCardID method.
		GetLastByCardID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CardID is the cardID argument value.
			CardID uuid.UUID
		}
		// GetStreakDays holds details about calls to the GetStreakDays method.
		GetStreakDays []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// DayStart is the dayStart argument value.
			DayStart time.Time
			// LastNDays is the lastNDays argument value.
			LastNDays int
		}
	}
	lockCountNewToday   sync.RWMutex
	lockCountToday      sync.RWMutex
	lockCreate          sync.RWMutex
	lockDelete          sync.RWMutex
	lockGetByCardID     sync.RWMutex
	lockGetByPeriod     sync.RWMutex
	lockGetLastByCardID sync.RWMutex
	lockGetStreakDays   sync.RWMutex
}

// CountNewToday calls CountNewTodayFunc.
func (mock *reviewLogRepoMock) CountNewToday(ctx context.Context, userID uuid.UUID, dayStart time.Time) (int, error) {
	if mock.CountNewTodayFunc == nil {
		panic("reviewLogRepoMock.CountNewTodayFunc: method is nil but reviewLogRepo.CountNewToday was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		UserID   uuid.UUID
		DayStart time.Time
	}{
		Ctx:      ctx,
		UserID:   userID,
		DayStart: dayStart,
	}
	mock.lockCountNewToday.Lock()
	mock.calls.CountNewToday = append(mock.calls.CountNewToday, callInfo)
	mock.lockCountNewToday.Unlock()
	return mock.CountNewTodayFunc(ctx, userID, dayStart)
}

// CountNewTodayCalls gets all the calls that were made to CountNewToday.
// Check the length with:
//
//	len(mockedreviewLogRepo.CountNewTodayCalls())
func (mock *reviewLogRepoMock) CountNewTodayCalls() []struct {
	Ctx      context.Context
	UserID   uuid.UUID
	DayStart time.Time
} {
	var calls []struct {
		Ctx      context.Context
		UserID   uuid.UUID
		DayStart time.Time
	}
	mock.lockCountNewToday.RLock()
	calls = mock.calls.CountNewToday
	mock.lockCountNewToday.RUnlock()
	return calls
}

// CountToday calls CountTodayFunc.
func (mock *reviewLogRepoMock) CountToday(ctx context.Context, userID uuid.UUID, dayStart time.Time) (int, error) {
	if mock.CountTodayFunc == nil {
		panic("reviewLogRepoMock.CountTodayFunc: method is nil but reviewLogRepo.CountToday was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		UserID   uuid.UUID
		DayStart time.Time
	}{
		Ctx:      ctx,
		UserID:   userID,
		DayStart: dayStart,
	}
	mock.lockCountToday.Lock()
	mock.calls.CountToday = append(mock.calls.CountToday, callInfo)
	mock.lockCountToday.Unlock()
	return mock.CountTodayFunc(ctx, userID, dayStart)
}

// CountTodayCalls gets all the calls that were made to CountToday.
// Check the length with:
//
//	len(mockedreviewLogRepo.CountTodayCalls())
func (mock *reviewLogRepoMock) CountTodayCalls() []struct {
	Ctx      context.Context
	UserID   uuid.UUID
	DayStart time.Time
} {
	var calls []struct {
		Ctx      context.Context
		UserID   uuid.UUID
		DayStart time.Time
	}
	mock.lockCountToday.RLock()
	calls = mock.calls.CountToday
	mock.lockCountToday.RUnlock()
	return calls
}

// Create calls CreateFunc.
func (mock *reviewLogRepoMock) Create(ctx context.Context, log *domain.ReviewLog) (*domain.ReviewLog, error) {
	if mock.CreateFunc == nil {
		panic("reviewLogRepoMock.CreateFunc: method is nil but reviewLogRepo.Create was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Log *domain.ReviewLog
	}{
		Ctx: ctx,
		Log: log,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, log)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedreviewLogRepo.CreateCalls())
func (mock *reviewLogRepoMock) CreateCalls() []struct {
	Ctx context.Context
	Log *domain.ReviewLog
} {
	var calls []struct {
		Ctx context.Context
		Log *domain.ReviewLog
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *reviewLogRepoMock) Delete(ctx context.Context, id uuid.UUID) error {
	if mock.DeleteFunc == nil {
		panic("reviewLogRepoMock.DeleteFunc: method is nil but reviewLogRepo.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, id)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedreviewLogRepo.DeleteCalls())
func (mock *reviewLogRepoMock) DeleteCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// GetByCardID calls GetByCardIDFunc.
func (mock *reviewLogRepoMock) GetByCardID(ctx context.Context, cardID uuid.UUID, limit int, offset int) ([]*domain.ReviewLog, int, error) {
	if mock.GetByCardIDFunc == nil {
		panic("reviewLogRepoMock.GetByCardIDFunc: method is nil but reviewLogRepo.GetByCardID was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		CardID uuid.UUID
		Limit  int
		Offset int
	}{
		Ctx:    ctx,
		CardID: cardID,
		Limit:  limit,
		Offset: offset,
	}
	mock.lockGetByCardID.Lock()
	mock.calls.GetByCardID = append(mock.calls.GetByCardID, callInfo)
	mock.lockGetByCardID.Unlock()
	return mock.GetByCardIDFunc(ctx, cardID, limit, offset)
}

// GetByCardIDCalls gets all the calls that were made to GetByCardID.
// Check the length with:
//
//	len(mockedreviewLogRepo.GetByCardIDCalls())
func (mock *reviewLogRepoMock) GetByCardIDCalls() []struct {
	Ctx    context.Context
	CardID uuid.UUID
	Limit  int
	Offset int
} {
	var calls []struct {
		Ctx    context.Context
		CardID uuid.UUID
		Limit  int
		Offset int
	}
	mock.lockGetByCardID.RLock()
	calls = mock.calls.GetByCardID
	mock.lockGetByCardID.RUnlock()
	return calls
}

// GetByPeriod calls GetByPeriodFunc.
func (mock *reviewLogRepoMock) GetByPeriod(ctx context.Context, userID uuid.UUID, from time.Time, to time.Time) ([]*domain.ReviewLog, error) {
	if mock.GetByPeriodFunc == nil {
		panic("reviewLogRepoMock.GetByPeriodFunc: method is nil but reviewLogRepo.GetByPeriod was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
		From   time.Time
		To     time.Time
	}{
		Ctx:    ctx,
		UserID: userID,
		From:   from,
		To:     to,
	}
	mock.lockGetByPeriod.Lock()
	mock.calls.GetByPeriod = append(mock.calls.GetByPeriod, callInfo)
	mock.lockGetByPeriod.Unlock()
	return mock.GetByPeriodFunc(ctx, userID, from, to)
}

// GetByPeriodCalls gets all the calls that were made to GetByPeriod.
// Check the length with:
//
//	len(mockedreviewLogRepo.GetByPeriodCalls())
func (mock *reviewLogRepoMock) GetByPeriodCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
	From   time.Time
	To     time.Time
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
		From   time.Time
		To     time.Time
	}
	mock.lockGetByPeriod.RLock()
	calls = mock.calls.GetByPeriod
	mock.lockGetByPeriod.RUnlock()
	return calls
}

// GetLastByCardID calls GetLastByCardIDFunc.
func (mock *reviewLogRepoMock) GetLastByCardID(ctx context.Context, cardID uuid.UUID) (*domain.ReviewLog, error) {
	if mock.GetLastByCardIDFunc == nil {
		panic("reviewLogRepoMock.GetLastByCardIDFunc: method is nil but reviewLogRepo.GetLastByCardID was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		CardID uuid.UUID
	}{
		Ctx:    ctx,
		CardID: cardID,
	}
	mock.lockGetLastByCardID.Lock()
	mock.calls.GetLastByCardID = append(mock.calls.GetLastByCardID, callInfo)
	mock.lockGetLastByCardID.Unlock()
	return mock.GetLastByCardIDFunc(ctx, cardID)
}

// GetLastByCardIDCalls gets all the calls that were made to GetLastByCardID.
// Check the length with:
//
//	len(mockedreviewLogRepo.GetLastByCardIDCalls())
func (mock *reviewLogRepoMock) GetLastByCardIDCalls() []struct {
	Ctx    context.Context
	CardID uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		CardID uuid.UUID
	}
	mock.lockGetLastByCardID.RLock()
	calls = mock.calls.GetLastByCardID
	mock.lockGetLastByCardID.RUnlock()
	return calls
}

// GetStreakDays calls GetStreakDaysFunc.
func (mock *reviewLogRepoMock) GetStreakDays(ctx context.Context, userID uuid.UUID, dayStart time.Time, lastNDays int) ([]domain.DayReviewCount, error) {
	if mock.GetStreakDaysFunc == nil {
		panic("reviewLogRepoMock.GetStreakDaysFunc: method is nil but reviewLogRepo.GetStreakDays was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		UserID    uuid.UUID
		DayStart  time.Time
		LastNDays int
	}{
		Ctx:       ctx,
		UserID:    userID,
		DayStart:  dayStart,
		LastNDays: lastNDays,
	}
	mock.lockGetStreakDays.Lock()
	mock.calls.GetStreakDays = append(mock.calls.GetStreakDays, callInfo)
	mock.lockGetStreakDays.Unlock()
	return mock.GetStreakDaysFunc(ctx, userID, dayStart, lastNDays)
}

// GetStreakDaysCalls gets all the calls that were made to GetStreakDays.
// Check the length with:
//
//	len(mockedreviewLogRepo.GetStreakDaysCalls())
func (mock *reviewLogRepoMock) GetStreakDaysCalls() []struct {
	Ctx       context.Context
	UserID    uuid.UUID
	DayStart  time.Time
	LastNDays int
} {
	var calls []struct {
		Ctx       context.Context
		UserID    uuid.UUID
		DayStart  time.Time
		LastNDays int
	}
	mock.lockGetStreakDays.RLock()
	calls = mock.calls.GetStreakDays
	mock.lockGetStreakDays.RUnlock()
	return calls
}

// Ensure, that sessionRepoMock does implement sessionRepo.
// If this is not the case, regenerate this file with moq.
var _ sessionRepo = &sessionRepoMock{}

// sessionRepoMock is a mock implementation of sessionRepo.
//
//	func TestSomethingThatUsessessionRepo(t *testing.T) {
//
//		// make and configure a mocked sessionRepo
//		mockedsessionRepo := &sessionRepoMock{
//			AbandonFunc: func(ctx context.Context, userID uuid.UUID, sessionID uuid.UUID) error {
//				panic("mock out the Abandon method")
//			},
//			CreateFunc: func(ctx context.Context, session *domain.StudySession) (*domain.StudySession, error) {
//				panic("mock out the Create method")
//			},
//			FinishFunc: func(ctx context.Context, userID uuid.UUID, sessionID uuid.UUID, result domain.SessionResult) (*domain.StudySession, error) {
//				panic("mock out the Finish method")
//			},
//			GetActiveFunc: func(ctx context.Context, userID uuid.UUID) (*domain.StudySession, error) {
//				panic("mock out the GetActive method")
//			},
//			GetByIDFunc: func(ctx context.Context, userID uuid.UUID, sessionID uuid.UUID) (*domain.StudySession, error) {
//				panic("mock out the GetByID method")
//			},
//			GetByUserIDFunc: func(ctx context.Context, userID uuid.UUID, limit int, offset int) ([]*domain.StudySession, int, error) {
//				panic("mock out the GetByUserID method")
//			},
//		}
//
//		// use mockedsessionRepo in code that requires sessionRepo
//		// and then make assertions.
//
//	}
type sessionRepoMock struct {
	// AbandonFunc mocks the Abandon method.
	AbandonFunc func(ctx context.Context, userID uuid.UUID, sessionID uuid.UUID) error

	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, session *domain.StudySession) (*domain.StudySession, error)

	// FinishFunc mocks the Finish method.
	FinishFunc func(ctx context.Context, userID uuid.UUID, sessionID uuid.UUID, result domain.SessionResult) (*domain.StudySession, error)

	// GetActiveFunc mocks the GetActive method.
	GetActiveFunc func(ctx context.Context, userID uuid.UUID) (*domain.StudySession, error)

	// GetByIDFunc mocks the GetByID method.
	GetByIDFunc func(ctx context.Context, userID uuid.UUID, sessionID uuid.UUID) (*domain.StudySession, error)

	// GetByUserIDFunc mocks the GetByUserID method.
	GetByUserIDFunc func(ctx context.Context, userID uuid.UUID, limit int, offset int) ([]*domain.StudySession, int, error)

	// calls tracks calls to the methods.
	calls struct {
		// Abandon holds details about calls to the Abandon method.
		Abandon []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// SessionID is the sessionID argument value.
			SessionID uuid.UUID
		}
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Session is the session argument value.
			Session *domain.StudySession
		}
		// Finish holds details about calls to the Finish method.
		Finish []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// SessionID is the sessionID argument value.
			SessionID uuid.UUID
			// Result is the result argument value.
			Result domain.SessionResult
		}
		// GetActive holds details about calls to the GetActive method.
		GetActive []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
		}
		// GetByID holds details about calls to the GetByID method.
		GetByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// SessionID is the sessionID argument value.
			SessionID uuid.UUID
		}
		// GetByUserID holds details about calls to the GetByUserID method.
		GetByUserID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// Limit is the limit argument value.
			Limit int
			// Offset is the offset argument value.
			Offset int
		}
	}
	lockAbandon     sync.RWMutex
	lockCreate      sync.RWMutex
	lockFinish      sync.RWMutex
	lockGetActive   sync.RWMutex
	lockGetByID     sync.RWMutex
	lockGetByUserID sync.RWMutex
}

// Abandon calls AbandonFunc.
func (mock *sessionRepoMock) Abandon(ctx context.Context, userID uuid.UUID, sessionID uuid.UUID) error {
	if mock.AbandonFunc == nil {
		panic("sessionRepoMock.AbandonFunc: method is nil but sessionRepo.Abandon was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		UserID    uuid.UUID
		SessionID uuid.UUID
	}{
		Ctx:       ctx,
		UserID:    userID,
		SessionID: sessionID,
	}
	mock.lockAbandon.Lock()
	mock.calls.Abandon = append(mock.calls.Abandon, callInfo)
	mock.lockAbandon.Unlock()
	return mock.AbandonFunc(ctx, userID, sessionID)
}

// AbandonCalls gets all the calls that were made to Abandon.
// Check the length with:
//
//	len(mockedsessionRepo.AbandonCalls())
func (mock *sessionRepoMock) AbandonCalls() []struct {
	Ctx       context.Context
	UserID    uuid.UUID
	SessionID uuid.UUID
} {
	var calls []struct {
		Ctx       context.Context
		UserID    uuid.UUID
		SessionID uuid.UUID
	}
	mock.lockAbandon.RLock()
	calls = mock.calls.Abandon
	mock.lockAbandon.RUnlock()
	return calls
}

// Create calls CreateFunc.
func (mock *sessionRepoMock) Create(ctx context.Context, session *domain.StudySession) (*domain.StudySession, error) {
	if mock.CreateFunc == nil {
		panic("sessionRepoMock.CreateFunc: method is nil but sessionRepo.Create was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Session *domain.StudySession
	}{
		Ctx:     ctx,
		Session: session,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, session)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedsessionRepo.CreateCalls())
func (mock *sessionRepoMock) CreateCalls() []struct {
	Ctx     context.Context
	Session *domain.StudySession
} {
	var calls []struct {
		Ctx     context.Context
		Session *domain.StudySession
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Finish calls FinishFunc.
func (mock *sessionRepoMock) Finish(ctx context.Context, userID uuid.UUID, sessionID uuid.UUID, result domain.SessionResult) (*domain.StudySession, error) {
	if mock.FinishFunc == nil {
		panic("sessionRepoMock.FinishFunc: method is nil but sessionRepo.Finish was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		UserID    uuid.UUID
		SessionID uuid.UUID
		Result    domain.SessionResult
	}{
		Ctx:       ctx,
		UserID:    userID,
		SessionID: sessionID,
		Result:    result,
	}
	mock.lockFinish.Lock()
	mock.calls.Finish = append(mock.calls.Finish, callInfo)
	mock.lockFinish.Unlock()
	return mock.FinishFunc(ctx, userID, sessionID, result)
}

// FinishCalls gets all the calls that were made to Finish.
// Check the length with:
//
//	len(mockedsessionRepo.FinishCalls())
func (mock *sessionRepoMock) FinishCalls() []struct {
	Ctx       context.Context
	UserID    uuid.UUID
	SessionID uuid.UUID
	Result    domain.SessionResult
} {
	var calls []struct {
		Ctx       context.Context
		UserID    uuid.UUID
		SessionID uuid.UUID
		Result    domain.SessionResult
	}
	mock.lockFinish.RLock()
	calls = mock.calls.Finish
	mock.lockFinish.RUnlock()
	return calls
}

// GetActive calls GetActiveFunc.
func (mock *sessionRepoMock) GetActive(ctx context.Context, userID uuid.UUID) (*domain.StudySession, error) {
	if mock.GetActiveFunc == nil {
		panic("sessionRepoMock.GetActiveFunc: method is nil but sessionRepo.GetActive was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockGetActive.Lock()
	mock.calls.GetActive = append(mock.calls.GetActive, callInfo)
	mock.lockGetActive.Unlock()
	return mock.GetActiveFunc(ctx, userID)
}

// GetActiveCalls gets all the calls that were made to GetActive.
// Check the length with:
//
//	len(mockedsessionRepo.GetActiveCalls())
func (mock *sessionRepoMock) GetActiveCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
	}
	mock.lockGetActive.RLock()
	calls = mock.calls.GetActive
	mock.lockGetActive.RUnlock()
	return calls
}

// GetByID calls GetByIDFunc.
func (mock *sessionRepoMock) GetByID(ctx context.Context, userID uuid.UUID, sessionID uuid.UUID) (*domain.StudySession, error) {
	if mock.GetByIDFunc == nil {
		panic("sessionRepoMock.GetByIDFunc: method is nil but sessionRepo.GetByID was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		UserID    uuid.UUID
		SessionID uuid.UUID
	}{
		Ctx:       ctx,
		UserID:    userID,
		SessionID: sessionID,
	}
	mock.lockGetByID.Lock()
	mock.calls.GetByID = append(mock.calls.GetByID, callInfo)
	mock.lockGetByID.Unlock()
	return mock.GetByIDFunc(ctx, userID, sessionID)
}

// GetByIDCalls gets all the calls that were made to GetByID.
// Check the length with:
//
//	len(mockedsessionRepo.GetByIDCalls())
func (mock *sessionRepoMock) GetByIDCalls() []struct {
	Ctx       context.Context
	UserID    uuid.UUID
	SessionID uuid.UUID
} {
	var calls []struct {
		Ctx       context.Context
		UserID    uuid.UUID
		SessionID uuid.UUID
	}
	mock.lockGetByID.RLock()
	calls = mock.calls.GetByID
	mock.lockGetByID.RUnlock()
	return calls
}

// GetByUserID calls GetByUserIDFunc.
func (mock *sessionRepoMock) GetByUserID(ctx context.Context, userID uuid.UUID, limit int, offset int) ([]*domain.StudySession, int, error) {
	if mock.GetByUserIDFunc == nil {
		panic("sessionRepoMock.GetByUserIDFunc: method is nil but sessionRepo.GetByUserID was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
		Limit  int
		Offset int
	}{
		Ctx:    ctx,
		UserID: userID,
		Limit:  limit,
		Offset: offset,
	}
	mock.lockGetByUserID.Lock()
	mock.calls.GetByUserID = append(mock.calls.GetByUserID, callInfo)
	mock.lockGetByUserID.Unlock()
	return mock.GetByUserIDFunc(ctx, userID, limit, offset)
}

// GetByUserIDCalls gets all the calls that were made to GetByUserID.
// Check the length with:
//
//	len(mockedsessionRepo.GetByUserIDCalls())
func (mock *sessionRepoMock) GetByUserIDCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
	Limit  int
	Offset int
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
		Limit  int
		Offset int
	}
	mock.lockGetByUserID.RLock()
	calls = mock.calls.GetByUserID
	mock.lockGetByUserID.RUnlock()
	return calls
}

// Ensure, that entryRepoMock does implement entryRepo.
// If this is not the case, regenerate this file with moq.
var _ entryRepo = &entryRepoMock{}

// entryRepoMock is a mock implementation of entryRepo.
//
//	func TestSomethingThatUsesentryRepo(t *testing.T) {
//
//		// make and configure a mocked entryRepo
//		mockedentryRepo := &entryRepoMock{
//			ExistByIDsFunc: func(ctx context.Context, userID uuid.UUID, ids []uuid.UUID) (map[uuid.UUID]bool, error) {
//				panic("mock out the ExistByIDs method")
//			},
//			GetByIDFunc: func(ctx context.Context, userID uuid.UUID, entryID uuid.UUID) (*domain.Entry, error) {
//				panic("mock out the GetByID method")
//			},
//		}
//
//		// use mockedentryRepo in code that requires entryRepo
//		// and then make assertions.
//
//	}
type entryRepoMock struct {
	// ExistByIDsFunc mocks the ExistByIDs method.
	ExistByIDsFunc func(ctx context.Context, userID uuid.UUID, ids []uuid.UUID) (map[uuid.UUID]bool, error)

	// GetByIDFunc mocks the GetByID method.
	GetByIDFunc func(ctx context.Context, userID uuid.UUID, entryID uuid.UUID) (*domain.Entry, error)

	// calls tracks calls to the methods.
	calls struct {
		// ExistByIDs holds details about calls to the ExistByIDs method.
		ExistByIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// Ids is the ids argument value.
			Ids []uuid.UUID
		}
		// GetByID holds details about calls to the GetByID method.
		GetByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// EntryID is the entryID argument value.
			EntryID uuid.UUID
		}
	}
	lockExistByIDs sync.RWMutex
	lockGetByID    sync.RWMutex
}

// ExistByIDs calls ExistByIDsFunc.
func (mock *entryRepoMock) ExistByIDs(ctx context.Context, userID uuid.UUID, ids []uuid.UUID) (map[uuid.UUID]bool, error) {
	if mock.ExistByIDsFunc == nil {
		panic("entryRepoMock.ExistByIDsFunc: method is nil but entryRepo.ExistByIDs was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
		Ids    []uuid.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
		Ids:    ids,
	}
	mock.lockExistByIDs.Lock()
	mock.calls.ExistByIDs = append(mock.calls.ExistByIDs, callInfo)
	mock.lockExistByIDs.Unlock()
	return mock.ExistByIDsFunc(ctx, userID, ids)
}

// ExistByIDsCalls gets all the calls that were made to ExistByIDs.
// Check the length with:
//
//	len(mockedentryRepo.ExistByIDsCalls())
func (mock *entryRepoMock) ExistByIDsCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
	Ids    []uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
		Ids    []uuid.UUID
	}
	mock.lockExistByIDs.RLock()
	calls = mock.calls.ExistByIDs
	mock.lockExistByIDs.RUnlock()
	return calls
}

// GetByID calls GetByIDFunc.
func (mock *entryRepoMock) GetByID(ctx context.Context, userID uuid.UUID, entryID uuid.UUID) (*domain.Entry, error) {
	if mock.GetByIDFunc == nil {
		panic("entryRepoMock.GetByIDFunc: method is nil but entryRepo.GetByID was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		UserID  uuid.UUID
		EntryID uuid.UUID
	}{
		Ctx:     ctx,
		UserID:  userID,
		EntryID: entryID,
	}
	mock.lockGetByID.Lock()
	mock.calls.GetByID = append(mock.calls.GetByID, callInfo)
	mock.lockGetByID.Unlock()
	return mock.GetByIDFunc(ctx, userID, entryID)
}

// GetByIDCalls gets all the calls that were made to GetByID.
// Check the length with:
//
//	len(mockedentryRepo.GetByIDCalls())
func (mock *entryRepoMock) GetByIDCalls() []struct {
	Ctx     context.Context
	UserID  uuid.UUID
	EntryID uuid.UUID
} {
	var calls []struct {
		Ctx     context.Context
		UserID  uuid.UUID
		EntryID uuid.UUID
	}
	mock.lockGetByID.RLock()
	calls = mock.calls.GetByID
	mock.lockGetByID.RUnlock()
	return calls
}

// Ensure, that senseRepoMock does implement senseRepo.
// If this is not the case, regenerate this file with moq.
var _ senseRepo = &senseRepoMock{}

// senseRepoMock is a mock implementation of senseRepo.
//
//	func TestSomethingThatUsessenseRepo(t *testing.T) {
//
//		// make and configure a mocked senseRepo
//		mockedsenseRepo := &senseRepoMock{
//			CountByEntryIDFunc: func(ctx context.Context, entryID uuid.UUID) (int, error) {
//				panic("mock out the CountByEntryID method")
//			},
//		}
//
//		// use mockedsenseRepo in code that requires senseRepo
//		// and then make assertions.
//
//	}
type senseRepoMock struct {
	// CountByEntryIDFunc mocks the CountByEntryID method.
	CountByEntryIDFunc func(ctx context.Context, entryID uuid.UUID) (int, error)

	// calls tracks calls to the methods.
	calls struct {
		// CountByEntryID holds details about calls to the CountByEntryID method.
		CountByEntryID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// EntryID is the entryID argument value.
			EntryID uuid.UUID
		}
	}
	lockCountByEntryID sync.RWMutex
}

// CountByEntryID calls CountByEntryIDFunc.
func (mock *senseRepoMock) CountByEntryID(ctx context.Context, entryID uuid.UUID) (int, error) {
	if mock.CountByEntryIDFunc == nil {
		panic("senseRepoMock.CountByEntryIDFunc: method is nil but senseRepo.CountByEntryID was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		EntryID uuid.UUID
	}{
		Ctx:     ctx,
		EntryID: entryID,
	}
	mock.lockCountByEntryID.Lock()
	mock.calls.CountByEntryID = append(mock.calls.CountByEntryID, callInfo)
	mock.lockCountByEntryID.Unlock()
	return mock.CountByEntryIDFunc(ctx, entryID)
}

// CountByEntryIDCalls gets all the calls that were made to CountByEntryID.
// Check the length with:
//
//	len(mockedsenseRepo.CountByEntryIDCalls())
func (mock *senseRepoMock) CountByEntryIDCalls() []struct {
	Ctx     context.Context
	EntryID uuid.UUID
} {
	var calls []struct {
		Ctx     context.Context
		EntryID uuid.UUID
	}
	mock.lockCountByEntryID.RLock()
	calls = mock.calls.CountByEntryID
	mock.lockCountByEntryID.RUnlock()
	return calls
}

// Ensure, that settingsRepoMock does implement settingsRepo.
// If this is not the case, regenerate this file with moq.
var _ settingsRepo = &settingsRepoMock{}

// settingsRepoMock is a mock implementation of settingsRepo.
//
//	func TestSomethingThatUsessettingsRepo(t *testing.T) {
//
//		// make and configure a mocked settingsRepo
//		mockedsettingsRepo := &settingsRepoMock{
//			GetByUserIDFunc: func(ctx context.Context, userID uuid.UUID) (*domain.UserSettings, error) {
//				panic("mock out the GetByUserID method")
//			},
//		}
//
//		// use mockedsettingsRepo in code that requires settingsRepo
//		// and then make assertions.
//
//	}
type settingsRepoMock struct {
	// GetByUserIDFunc mocks the GetByUserID method.
	GetByUserIDFunc func(ctx context.Context, userID uuid.UUID) (*domain.UserSettings, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetByUserID holds details about calls to the GetByUserID method.
		GetByUserID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
		}
	}
	lockGetByUserID sync.RWMutex
}

// GetByUserID calls GetByUserIDFunc.
func (mock *settingsRepoMock) GetByUserID(ctx context.Context, userID uuid.UUID) (*domain.UserSettings, error) {
	if mock.GetByUserIDFunc == nil {
		panic("settingsRepoMock.GetByUserIDFunc: method is nil but settingsRepo.GetByUserID was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockGetByUserID.Lock()
	mock.calls.GetByUserID = append(mock.calls.GetByUserID, callInfo)
	mock.lockGetByUserID.Unlock()
	return mock.GetByUserIDFunc(ctx, userID)
}

// GetByUserIDCalls gets all the calls that were made to GetByUserID.
// Check the length with:
//
//	len(mockedsettingsRepo.GetByUserIDCalls())
func (mock *settingsRepoMock) GetByUserIDCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
	}
	mock.lockGetByUserID.RLock()
	calls = mock.calls.GetByUserID
	mock.lockGetByUserID.RUnlock()
	return calls
}

// Ensure, that auditLoggerMock does implement auditLogger.
// If this is not the case, regenerate this file with moq.
var _ auditLogger = &auditLoggerMock{}

// auditLoggerMock is a mock implementation of auditLogger.
//
//	func TestSomethingThatUsesauditLogger(t *testing.T) {
//
//		// make and configure a mocked auditLogger
//		mockedauditLogger := &auditLoggerMock{
//			LogFunc: func(ctx context.Context, record domain.AuditRecord) error {
//				panic("mock out the Log method")
//			},
//		}
//
//		// use mockedauditLogger in code that requires auditLogger
//		// and then make assertions.
//
//	}
type auditLoggerMock struct {
	// LogFunc mocks the Log method.
	LogFunc func(ctx context.Context, record domain.AuditRecord) error

	// calls tracks calls to the methods.
	calls struct {
		// Log holds details about calls to the Log method.
		Log []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Record is the record argument value.
			Record domain.AuditRecord
		}
	}
	lockLog sync.RWMutex
}

// Log calls LogFunc.
func (mock *auditLoggerMock) Log(ctx context.Context, record domain.AuditRecord) error {
	if mock.LogFunc == nil {
		panic("auditLoggerMock.LogFunc: method is nil but auditLogger.Log was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Record domain.AuditRecord
	}{
		Ctx:    ctx,
		Record: record,
	}
	mock.lockLog.Lock()
	mock.calls.Log = append(mock.calls.Log, callInfo)
	mock.lockLog.Unlock()
	return mock.LogFunc(ctx, record)
}

// LogCalls gets all the calls that were made to Log.
// Check the length with:
//
//	len(mockedauditLogger.LogCalls())
func (mock *auditLoggerMock) LogCalls() []struct {
	Ctx    context.Context
	Record domain.AuditRecord
} {
	var calls []struct {
		Ctx    context.Context
		Record domain.AuditRecord
	}
	mock.lockLog.RLock()
	calls = mock.calls.Log
	mock.lockLog.RUnlock()
	return calls
}

// Ensure, that txManagerMock does implement txManager.
// If this is not the case, regenerate this file with moq.
var _ txManager = &txManagerMock{}

// txManagerMock is a mock implementation of txManager.
//
//	func TestSomethingThatUsestxManager(t *testing.T) {
//
//		// make and configure a mocked txManager
//		mockedtxManager := &txManagerMock{
//			RunInTxFunc: func(ctx context.Context, fn func(ctx context.Context) error) error {
//				panic("mock out the RunInTx method")
//			},
//		}
//
//		// use mockedtxManager in code that requires txManager
//		// and then make assertions.
//
//	}
type txManagerMock struct {
	// RunInTxFunc mocks the RunInTx method.
	RunInTxFunc func(ctx context.Context, fn func(ctx context.Context) error) error

	// calls tracks calls to the methods.
	calls struct {
		// RunInTx holds details about calls to the RunInTx method.
		RunInTx []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Fn is the fn argument value.
			Fn func(ctx context.Context) error
		}
	}
	lockRunInTx sync.RWMutex
}

// RunInTx calls RunInTxFunc.
func (mock *txManagerMock) RunInTx(ctx context.Context, fn func(ctx context.Context) error) error {
	if mock.RunInTxFunc == nil {
		panic("txManagerMock.RunInTxFunc: method is nil but txManager.RunInTx was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Fn  func(ctx context.Context) error
	}{
		Ctx: ctx,
		Fn:  fn,
	}
	mock.lockRunInTx.Lock()
	mock.calls.RunInTx = append(mock.calls.RunInTx, callInfo)
	mock.lockRunInTx.Unlock()
	return mock.RunInTxFunc(ctx, fn)
}

// RunInTxCalls gets all the calls that were made to RunInTx.
// Check the length with:
//
//	len(mockedtxManager.RunInTxCalls())
func (mock *txManagerMock) RunInTxCalls() []struct {
	Ctx context.Context
	Fn  func(ctx context.Context) error
} {
	var calls []struct {
		Ctx context.Context
		Fn  func(ctx context.Context) error
	}
	mock.lockRunInTx.RLock()
	calls = mock.calls.RunInTx
	mock.lockRunInTx.RUnlock()
	return calls
}
