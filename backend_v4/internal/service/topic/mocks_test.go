// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package topic

import (
	"context"
	"github.com/google/uuid"
	"github.com/heartmarshall/myenglish-backend/internal/domain"
	"sync"
)

// Ensure, that topicRepoMock does implement topicRepo.
// If this is not the case, regenerate this file with moq.
var _ topicRepo = &topicRepoMock{}

// topicRepoMock is a mock implementation of topicRepo.
//
//	func TestSomethingThatUsestopicRepo(t *testing.T) {
//
//		// make and configure a mocked topicRepo
//		mockedtopicRepo := &topicRepoMock{
//			BatchLinkEntriesFunc: func(ctx context.Context, entryIDs []uuid.UUID, topicID uuid.UUID) (int, error) {
//				panic("mock out the BatchLinkEntries method")
//			},
//			CountFunc: func(ctx context.Context, userID uuid.UUID) (int, error) {
//				panic("mock out the Count method")
//			},
//			CountEntriesByTopicIDFunc: func(ctx context.Context, topicID uuid.UUID) (int, error) {
//				panic("mock out the CountEntriesByTopicID method")
//			},
//			CreateFunc: func(ctx context.Context, userID uuid.UUID, topic *domain.Topic) (*domain.Topic, error) {
//				panic("mock out the Create method")
//			},
//			DeleteFunc: func(ctx context.Context, userID uuid.UUID, topicID uuid.UUID) error {
//				panic("mock out the Delete method")
//			},
//			GetByIDFunc: func(ctx context.Context, userID uuid.UUID, topicID uuid.UUID) (*domain.Topic, error) {
//				panic("mock out the GetByID method")
//			},
//			GetEntryIDsByTopicIDFunc: func(ctx context.Context, topicID uuid.UUID) ([]uuid.UUID, error) {
//				panic("mock out the GetEntryIDsByTopicID method")
//			},
//			GetTopicsByEntryIDFunc: func(ctx context.Context, entryID uuid.UUID) ([]*domain.Topic, error) {
//				panic("mock out the GetTopicsByEntryID method")
//			},
//			LinkEntryFunc: func(ctx context.Context, entryID uuid.UUID, topicID uuid.UUID) error {
//				panic("mock out the LinkEntry method")
//			},
//			ListFunc: func(ctx context.Context, userID uuid.UUID) ([]*domain.Topic, error) {
//				panic("mock out the List method")
//			},
//			UnlinkEntryFunc: func(ctx context.Context, entryID uuid.UUID, topicID uuid.UUID) error {
//				panic("mock out the UnlinkEntry method")
//			},
//			UpdateFunc: func(ctx context.Context, userID uuid.UUID, topicID uuid.UUID, params domain.TopicUpdateParams) (*domain.Topic, error) {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedtopicRepo in code that requires topicRepo
//		// and then make assertions.
//
//	}
type topicRepoMock struct {
	// BatchLinkEntriesFunc mocks the BatchLinkEntries method.
	BatchLinkEntriesFunc func(ctx context.Context, entryIDs []uuid.UUID, topicID uuid.UUID) (int, error)

	// CountFunc mocks the Count method.
	CountFunc func(ctx context.Context, userID uuid.UUID) (int, error)

	// CountEntriesByTopicIDFunc mocks the CountEntriesByTopicID method.
	CountEntriesByTopicIDFunc func(ctx context.Context, topicID uuid.UUID) (int, error)

	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, userID uuid.UUID, topic *domain.Topic) (*domain.Topic, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, userID uuid.UUID, topicID uuid.UUID) error

	// GetByIDFunc mocks the GetByID method.
	GetByIDFunc func(ctx context.Context, userID uuid.UUID, topicID uuid.UUID) (*domain.Topic, error)

	// GetEntryIDsByTopicIDFunc mocks the GetEntryIDsByTopicID method.
	GetEntryIDsByTopicIDFunc func(ctx context.Context, topicID uuid.UUID) ([]uuid.UUID, error)

	// GetTopicsByEntryIDFunc mocks the GetTopicsByEntryID method.
	GetTopicsByEntryIDFunc func(ctx context.Context, entryID uuid.UUID) ([]*domain.Topic, error)

	// LinkEntryFunc mocks the LinkEntry method.
	LinkEntryFunc func(ctx context.Context, entryID uuid.UUID, topicID uuid.UUID) error

	// ListFunc mocks the List method.
	ListFunc func(ctx context.Context, userID uuid.UUID) ([]*domain.Topic, error)

	// UnlinkEntryFunc mocks the UnlinkEntry method.
	UnlinkEntryFunc func(ctx context.Context, entryID uuid.UUID, topicID uuid.UUID) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, userID uuid.UUID, topicID uuid.UUID, params domain.TopicUpdateParams) (*domain.Topic, error)

	// calls tracks calls to the methods.
	calls struct {
		// BatchLinkEntries holds details about calls to the BatchLinkEntries method.
		BatchLinkEntries []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// EntryIDs is the entryIDs argument value.
			EntryIDs []uuid.UUID
			// TopicID is the topicID argument value.
			TopicID uuid.UUID
		}
		// Count holds details about calls to the Count method.
		Count []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
		}
		// CountEntriesByTopicID holds details about calls to the CountEntriesByTopicID method.
		CountEntriesByTopicID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TopicID is the topicID argument value.
			TopicID uuid.UUID
		}
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// Topic is the topic argument value.
			Topic *domain.Topic
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// TopicID is the topicID argument value.
			TopicID uuid.UUID
		}
		// GetByID holds details about calls to the GetByID method.
		GetByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// TopicID is the topicID argument value.
			TopicID uuid.UUID
		}
		// GetEntryIDsByTopicID holds details about calls to the GetEntryIDsByTopicID method.
		GetEntryIDsByTopicID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TopicID is the topicID argument value.
			TopicID uuid.UUID
		}
		// GetTopicsByEntryID holds details about calls to the GetTopicsByEntryID method.
		GetTopicsByEntryID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// EntryID is the entryID argument value.
			EntryID uuid.UUID
		}
		// LinkEntry holds details about calls to the LinkEntry method.
		LinkEntry []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// EntryID is the entryID argument value.
			EntryID uuid.UUID
			// TopicID is the topicID argument value.
			TopicID uuid.UUID
		}
		// List holds details about calls to the List method.
		List []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
		}
		// UnlinkEntry holds details about calls to the UnlinkEntry method.
		UnlinkEntry []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// EntryID is the entryID argument value.
			EntryID uuid.UUID
			// TopicID is the topicID argument value.
			TopicID uuid.UUID
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// TopicID is the topicID argument value.
			TopicID uuid.UUID
			// Params is the params argument value.
			Params domain.TopicUpdateParams
		}
	}
	lockBatchLinkEntries      sync.RWMutex
	lockCount                 sync.RWMutex
	lockCountEntriesByTopicID sync.RWMutex
	lockCreate                sync.RWMutex
	lockDelete                sync.RWMutex
	lockGetByID               sync.RWMutex
	lockGetEntryIDsByTopicID  sync.RWMutex
	lockGetTopicsByEntryID    sync.RWMutex
	lockLinkEntry             sync.RWMutex
	lockList                  sync.RWMutex
	lockUnlinkEntry           sync.RWMutex
	lockUpdate                sync.RWMutex
}

// BatchLinkEntries calls BatchLinkEntriesFunc.
func (mock *topicRepoMock) BatchLinkEntries(ctx context.Context, entryIDs []uuid.UUID, topicID uuid.UUID) (int, error) {
	if mock.BatchLinkEntriesFunc == nil {
		panic("topicRepoMock.BatchLinkEntriesFunc: method is nil but topicRepo.BatchLinkEntries was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		EntryIDs []uuid.UUID
		TopicID  uuid.UUID
	}{
		Ctx:      ctx,
		EntryIDs: entryIDs,
		TopicID:  topicID,
	}
	mock.lockBatchLinkEntries.Lock()
	mock.calls.BatchLinkEntries = append(mock.calls.BatchLinkEntries, callInfo)
	mock.lockBatchLinkEntries.Unlock()
	return mock.BatchLinkEntriesFunc(ctx, entryIDs, topicID)
}

// BatchLinkEntriesCalls gets all the calls that were made to BatchLinkEntries.
// Check the length with:
//
//	len(mockedtopicRepo.BatchLinkEntriesCalls())
func (mock *topicRepoMock) BatchLinkEntriesCalls() []struct {
	Ctx      context.Context
	EntryIDs []uuid.UUID
	TopicID  uuid.UUID
} {
	var calls []struct {
		Ctx      context.Context
		EntryIDs []uuid.UUID
		TopicID  uuid.UUID
	}
	mock.lockBatchLinkEntries.RLock()
	calls = mock.calls.BatchLinkEntries
	mock.lockBatchLinkEntries.RUnlock()
	return calls
}

// Count calls CountFunc.
func (mock *topicRepoMock) Count(ctx context.Context, userID uuid.UUID) (int, error) {
	if mock.CountFunc == nil {
		panic("topicRepoMock.CountFunc: method is nil but topicRepo.Count was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockCount.Lock()
	mock.calls.Count = append(mock.calls.Count, callInfo)
	mock.lockCount.Unlock()
	return mock.CountFunc(ctx, userID)
}

// CountCalls gets all the calls that were made to Count.
// Check the length with:
//
//	len(mockedtopicRepo.CountCalls())
func (mock *topicRepoMock) CountCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
	}
	mock.lockCount.RLock()
	calls = mock.calls.Count
	mock.lockCount.RUnlock()
	return calls
}

// CountEntriesByTopicID calls CountEntriesByTopicIDFunc.
func (mock *topicRepoMock) CountEntriesByTopicID(ctx context.Context, topicID uuid.UUID) (int, error) {
	if mock.CountEntriesByTopicIDFunc == nil {
		panic("topicRepoMock.CountEntriesByTopicIDFunc: method is nil but topicRepo.CountEntriesByTopicID was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		TopicID uuid.UUID
	}{
		Ctx:     ctx,
		TopicID: topicID,
	}
	mock.lockCountEntriesByTopicID.Lock()
	mock.calls.CountEntriesByTopicID = append(mock.calls.CountEntriesByTopicID, callInfo)
	mock.lockCountEntriesByTopicID.Unlock()
	return mock.CountEntriesByTopicIDFunc(ctx, topicID)
}

// CountEntriesByTopicIDCalls gets all the calls that were made to CountEntriesByTopicID.
// Check the length with:
//
//	len(mockedtopicRepo.CountEntriesByTopicIDCalls())
func (mock *topicRepoMock) CountEntriesByTopicIDCalls() []struct {
	Ctx     context.Context
	TopicID uuid.UUID
} {
	var calls []struct {
		Ctx     context.Context
		TopicID uuid.UUID
	}
	mock.lockCountEntriesByTopicID.RLock()
	calls = mock.calls.CountEntriesByTopicID
	mock.lockCountEntriesByTopicID.RUnlock()
	return calls
}

// Create calls CreateFunc.
func (mock *topicRepoMock) Create(ctx context.Context, userID uuid.UUID, topic *domain.Topic) (*domain.Topic, error) {
	if mock.CreateFunc == nil {
		panic("topicRepoMock.CreateFunc: method is nil but topicRepo.Create was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
		Topic  *domain.Topic
	}{
		Ctx:    ctx,
		UserID: userID,
		Topic:  topic,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, userID, topic)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedtopicRepo.CreateCalls())
func (mock *topicRepoMock) CreateCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
	Topic  *domain.Topic
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
		Topic  *domain.Topic
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *topicRepoMock) Delete(ctx context.Context, userID uuid.UUID, topicID uuid.UUID) error {
	if mock.DeleteFunc == nil {
		panic("topicRepoMock.DeleteFunc: method is nil but topicRepo.Delete was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		UserID  uuid.UUID
		TopicID uuid.UUID
	}{
		Ctx:     ctx,
		UserID:  userID,
		TopicID: topicID,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, userID, topicID)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedtopicRepo.DeleteCalls())
func (mock *topicRepoMock) DeleteCalls() []struct {
	Ctx     context.Context
	UserID  uuid.UUID
	TopicID uuid.UUID
} {
	var calls []struct {
		Ctx     context.Context
		UserID  uuid.UUID
		TopicID uuid.UUID
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// GetByID calls GetByIDFunc.
func (mock *topicRepoMock) GetByID(ctx context.Context, userID uuid.UUID, topicID uuid.UUID) (*domain.Topic, error) {
	if mock.GetByIDFunc == nil {
		panic("topicRepoMock.GetByIDFunc: method is nil but topicRepo.GetByID was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		UserID  uuid.UUID
		TopicID uuid.UUID
	}{
		Ctx:     ctx,
		UserID:  userID,
		TopicID: topicID,
	}
	mock.lockGetByID.Lock()
	mock.calls.GetByID = append(mock.calls.GetByID, callInfo)
	mock.lockGetByID.Unlock()
	return mock.GetByIDFunc(ctx, userID, topicID)
}

// GetByIDCalls gets all the calls that were made to GetByID.
// Check the length with:
//
//	len(mockedtopicRepo.GetByIDCalls())
func (mock *topicRepoMock) GetByIDCalls() []struct {
	Ctx     context.Context
	UserID  uuid.UUID
	TopicID uuid.UUID
} {
	var calls []struct {
		Ctx     context.Context
		UserID  uuid.UUID
		TopicID uuid.UUID
	}
	mock.lockGetByID.RLock()
	calls = mock.calls.GetByID
	mock.lockGetByID.RUnlock()
	return calls
}

// GetEntryIDsByTopicID calls GetEntryIDsByTopicIDFunc.
func (mock *topicRepoMock) GetEntryIDsByTopicID(ctx context.Context, topicID uuid.UUID) ([]uuid.UUID, error) {
	if mock.GetEntryIDsByTopicIDFunc == nil {
		panic("topicRepoMock.GetEntryIDsByTopicIDFunc: method is nil but topicRepo.GetEntryIDsByTopicID was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		TopicID uuid.UUID
	}{
		Ctx:     ctx,
		TopicID: topicID,
	}
	mock.lockGetEntryIDsByTopicID.Lock()
	mock.calls.GetEntryIDsByTopicID = append(mock.calls.GetEntryIDsByTopicID, callInfo)
	mock.lockGetEntryIDsByTopicID.Unlock()
	return mock.GetEntryIDsByTopicIDFunc(ctx, topicID)
}

// GetEntryIDsByTopicIDCalls gets all the calls that were made to GetEntryIDsByTopicID.
// Check the length with:
//
//	len(mockedtopicRepo.GetEntryIDsByTopicIDCalls())
func (mock *topicRepoMock) GetEntryIDsByTopicIDCalls() []struct {
	Ctx     context.Context
	TopicID uuid.UUID
} {
	var calls []struct {
		Ctx     context.Context
		TopicID uuid.UUID
	}
	mock.lockGetEntryIDsByTopicID.RLock()
	calls = mock.calls.GetEntryIDsByTopicID
	mock.lockGetEntryIDsByTopicID.RUnlock()
	return calls
}

// GetTopicsByEntryID calls GetTopicsByEntryIDFunc.
func (mock *topicRepoMock) GetTopicsByEntryID(ctx context.Context, entryID uuid.UUID) ([]*domain.Topic, error) {
	if mock.GetTopicsByEntryIDFunc == nil {
		panic("topicRepoMock.GetTopicsByEntryIDFunc: method is nil but topicRepo.GetTopicsByEntryID was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		EntryID uuid.UUID
	}{
		Ctx:     ctx,
		EntryID: entryID,
	}
	mock.lockGetTopicsByEntryID.Lock()
	mock.calls.GetTopicsByEntryID = append(mock.calls.GetTopicsByEntryID, callInfo)
	mock.lockGetTopicsByEntryID.Unlock()
	return mock.GetTopicsByEntryIDFunc(ctx, entryID)
}

// GetTopicsByEntryIDCalls gets all the calls that were made to GetTopicsByEntryID.
// Check the length with:
//
//	len(mockedtopicRepo.GetTopicsByEntryIDCalls())
func (mock *topicRepoMock) GetTopicsByEntryIDCalls() []struct {
	Ctx     context.Context
	EntryID uuid.UUID
} {
	var calls []struct {
		Ctx     context.Context
		EntryID uuid.UUID
	}
	mock.lockGetTopicsByEntryID.RLock()
	calls = mock.calls.GetTopicsByEntryID
	mock.lockGetTopicsByEntryID.RUnlock()
	return calls
}

// LinkEntry calls LinkEntryFunc.
func (mock *topicRepoMock) LinkEntry(ctx context.Context, entryID uuid.UUID, topicID uuid.UUID) error {
	if mock.LinkEntryFunc == nil {
		panic("topicRepoMock.LinkEntryFunc: method is nil but topicRepo.LinkEntry was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		EntryID uuid.UUID
		TopicID uuid.UUID
	}{
		Ctx:     ctx,
		EntryID: entryID,
		TopicID: topicID,
	}
	mock.lockLinkEntry.Lock()
	mock.calls.LinkEntry = append(mock.calls.LinkEntry, callInfo)
	mock.lockLinkEntry.Unlock()
	return mock.LinkEntryFunc(ctx, entryID, topicID)
}

// LinkEntryCalls gets all the calls that were made to LinkEntry.
// Check the length with:
//
//	len(mockedtopicRepo.LinkEntryCalls())
func (mock *topicRepoMock) LinkEntryCalls() []struct {
	Ctx     context.Context
	EntryID uuid.UUID
	TopicID uuid.UUID
} {
	var calls []struct {
		Ctx     context.Context
		EntryID uuid.UUID
		TopicID uuid.UUID
	}
	mock.lockLinkEntry.RLock()
	calls = mock.calls.LinkEntry
	mock.lockLinkEntry.RUnlock()
	return calls
}

// List calls ListFunc.
func (mock *topicRepoMock) List(ctx context.Context, userID uuid.UUID) ([]*domain.Topic, error) {
	if mock.ListFunc == nil {
		panic("topicRepoMock.ListFunc: method is nil but topicRepo.List was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockList.Lock()
	mock.calls.List = append(mock.calls.List, callInfo)
	mock.lockList.Unlock()
	return mock.ListFunc(ctx, userID)
}

// ListCalls gets all the calls that were made to List.
// Check the length with:
//
//	len(mockedtopicRepo.ListCalls())
func (mock *topicRepoMock) ListCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
	}
	mock.lockList.RLock()
	calls = mock.calls.List
	mock.lockList.RUnlock()
	return calls
}

// UnlinkEntry calls UnlinkEntryFunc.
func (mock *topicRepoMock) UnlinkEntry(ctx context.Context, entryID uuid.UUID, topicID uuid.UUID) error {
	if mock.UnlinkEntryFunc == nil {
		panic("topicRepoMock.UnlinkEntryFunc: method is nil but topicRepo.UnlinkEntry was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		EntryID uuid.UUID
		TopicID uuid.UUID
	}{
		Ctx:     ctx,
		EntryID: entryID,
		TopicID: topicID,
	}
	mock.lockUnlinkEntry.Lock()
	mock.calls.UnlinkEntry = append(mock.calls.UnlinkEntry, callInfo)
	mock.lockUnlinkEntry.Unlock()
	return mock.UnlinkEntryFunc(ctx, entryID, topicID)
}

// UnlinkEntryCalls gets all the calls that were made to UnlinkEntry.
// Check the length with:
//
//	len(mockedtopicRepo.UnlinkEntryCalls())
func (mock *topicRepoMock) UnlinkEntryCalls() []struct {
	Ctx     context.Context
	EntryID uuid.UUID
	TopicID uuid.UUID
} {
	var calls []struct {
		Ctx     context.Context
		EntryID uuid.UUID
		TopicID uuid.UUID
	}
	mock.lockUnlinkEntry.RLock()
	calls = mock.calls.UnlinkEntry
	mock.lockUnlinkEntry.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *topicRepoMock) Update(ctx context.Context, userID uuid.UUID, topicID uuid.UUID, params domain.TopicUpdateParams) (*domain.Topic, error) {
	if mock.UpdateFunc == nil {
		panic("topicRepoMock.UpdateFunc: method is nil but topicRepo.Update was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		UserID  uuid.UUID
		TopicID uuid.UUID
		Params  domain.TopicUpdateParams
	}{
		Ctx:     ctx,
		UserID:  userID,
		TopicID: topicID,
		Params:  params,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, userID, topicID, params)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedtopicRepo.UpdateCalls())
func (mock *topicRepoMock) UpdateCalls() []struct {
	Ctx     context.Context
	UserID  uuid.UUID
	TopicID uuid.UUID
	Params  domain.TopicUpdateParams
} {
	var calls []struct {
		Ctx     context.Context
		UserID  uuid.UUID
		TopicID uuid.UUID
		Params  domain.TopicUpdateParams
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure, that entryRepoMock does implement entryRepo.
// If this is not the case, regenerate this file with moq.
var _ entryRepo = &entryRepoMock{}

// entryRepoMock is a mock implementation of entryRepo.
//
//	func TestSomethingThatUsesentryRepo(t *testing.T) {
//
//		// make and configure a mocked entryRepo
//		mockedentryRepo := &entryRepoMock{
//			ExistByIDsFunc: func(ctx context.Context, userID uuid.UUID, ids []uuid.UUID) (map[uuid.UUID]bool, error) {
//				panic("mock out the ExistByIDs method")
//			},
//			GetByIDFunc: func(ctx context.Context, userID uuid.UUID, entryID uuid.UUID) (*domain.Entry, error) {
//				panic("mock out the GetByID method")
//			},
//		}
//
//		// use mockedentryRepo in code that requires entryRepo
//		// and then make assertions.
//
//	}
type entryRepoMock struct {
	// ExistByIDsFunc mocks the ExistByIDs method.
	ExistByIDsFunc func(ctx context.Context, userID uuid.UUID, ids []uuid.UUID) (map[uuid.UUID]bool, error)

	// GetByIDFunc mocks the GetByID method.
	GetByIDFunc func(ctx context.Context, userID uuid.UUID, entryID uuid.UUID) (*domain.Entry, error)

	// calls tracks calls to the methods.
	calls struct {
		// ExistByIDs holds details about calls to the ExistByIDs method.
		ExistByIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// Ids is the ids argument value.
			Ids []uuid.UUID
		}
		// GetByID holds details about calls to the GetByID method.
		GetByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
			// EntryID is the entryID argument value.
			EntryID uuid.UUID
		}
	}
	lockExistByIDs sync.RWMutex
	lockGetByID    sync.RWMutex
}

// ExistByIDs calls ExistByIDsFunc.
func (mock *entryRepoMock) ExistByIDs(ctx context.Context, userID uuid.UUID, ids []uuid.UUID) (map[uuid.UUID]bool, error) {
	if mock.ExistByIDsFunc == nil {
		panic("entryRepoMock.ExistByIDsFunc: method is nil but entryRepo.ExistByIDs was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
		Ids    []uuid.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
		Ids:    ids,
	}
	mock.lockExistByIDs.Lock()
	mock.calls.ExistByIDs = append(mock.calls.ExistByIDs, callInfo)
	mock.lockExistByIDs.Unlock()
	return mock.ExistByIDsFunc(ctx, userID, ids)
}

// ExistByIDsCalls gets all the calls that were made to ExistByIDs.
// Check the length with:
//
//	len(mockedentryRepo.ExistByIDsCalls())
func (mock *entryRepoMock) ExistByIDsCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
	Ids    []uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
		Ids    []uuid.UUID
	}
	mock.lockExistByIDs.RLock()
	calls = mock.calls.ExistByIDs
	mock.lockExistByIDs.RUnlock()
	return calls
}

// GetByID calls GetByIDFunc.
func (mock *entryRepoMock) GetByID(ctx context.Context, userID uuid.UUID, entryID uuid.UUID) (*domain.Entry, error) {
	if mock.GetByIDFunc == nil {
		panic("entryRepoMock.GetByIDFunc: method is nil but entryRepo.GetByID was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		UserID  uuid.UUID
		EntryID uuid.UUID
	}{
		Ctx:     ctx,
		UserID:  userID,
		EntryID: entryID,
	}
	mock.lockGetByID.Lock()
	mock.calls.GetByID = append(mock.calls.GetByID, callInfo)
	mock.lockGetByID.Unlock()
	return mock.GetByIDFunc(ctx, userID, entryID)
}

// GetByIDCalls gets all the calls that were made to GetByID.
// Check the length with:
//
//	len(mockedentryRepo.GetByIDCalls())
func (mock *entryRepoMock) GetByIDCalls() []struct {
	Ctx     context.Context
	UserID  uuid.UUID
	EntryID uuid.UUID
} {
	var calls []struct {
		Ctx     context.Context
		UserID  uuid.UUID
		EntryID uuid.UUID
	}
	mock.lockGetByID.RLock()
	calls = mock.calls.GetByID
	mock.lockGetByID.RUnlock()
	return calls
}

// Ensure, that auditLoggerMock does implement auditLogger.
// If this is not the case, regenerate this file with moq.
var _ auditLogger = &auditLoggerMock{}

// auditLoggerMock is a mock implementation of auditLogger.
//
//	func TestSomethingThatUsesauditLogger(t *testing.T) {
//
//		// make and configure a mocked auditLogger
//		mockedauditLogger := &auditLoggerMock{
//			LogFunc: func(ctx context.Context, record domain.AuditRecord) error {
//				panic("mock out the Log method")
//			},
//		}
//
//		// use mockedauditLogger in code that requires auditLogger
//		// and then make assertions.
//
//	}
type auditLoggerMock struct {
	// LogFunc mocks the Log method.
	LogFunc func(ctx context.Context, record domain.AuditRecord) error

	// calls tracks calls to the methods.
	calls struct {
		// Log holds details about calls to the Log method.
		Log []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Record is the record argument value.
			Record domain.AuditRecord
		}
	}
	lockLog sync.RWMutex
}

// Log calls LogFunc.
func (mock *auditLoggerMock) Log(ctx context.Context, record domain.AuditRecord) error {
	if mock.LogFunc == nil {
		panic("auditLoggerMock.LogFunc: method is nil but auditLogger.Log was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Record domain.AuditRecord
	}{
		Ctx:    ctx,
		Record: record,
	}
	mock.lockLog.Lock()
	mock.calls.Log = append(mock.calls.Log, callInfo)
	mock.lockLog.Unlock()
	return mock.LogFunc(ctx, record)
}

// LogCalls gets all the calls that were made to Log.
// Check the length with:
//
//	len(mockedauditLogger.LogCalls())
func (mock *auditLoggerMock) LogCalls() []struct {
	Ctx    context.Context
	Record domain.AuditRecord
} {
	var calls []struct {
		Ctx    context.Context
		Record domain.AuditRecord
	}
	mock.lockLog.RLock()
	calls = mock.calls.Log
	mock.lockLog.RUnlock()
	return calls
}

// Ensure, that txManagerMock does implement txManager.
// If this is not the case, regenerate this file with moq.
var _ txManager = &txManagerMock{}

// txManagerMock is a mock implementation of txManager.
//
//	func TestSomethingThatUsestxManager(t *testing.T) {
//
//		// make and configure a mocked txManager
//		mockedtxManager := &txManagerMock{
//			RunInTxFunc: func(ctx context.Context, fn func(ctx context.Context) error) error {
//				panic("mock out the RunInTx method")
//			},
//		}
//
//		// use mockedtxManager in code that requires txManager
//		// and then make assertions.
//
//	}
type txManagerMock struct {
	// RunInTxFunc mocks the RunInTx method.
	RunInTxFunc func(ctx context.Context, fn func(ctx context.Context) error) error

	// calls tracks calls to the methods.
	calls struct {
		// RunInTx holds details about calls to the RunInTx method.
		RunInTx []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Fn is the fn argument value.
			Fn func(ctx context.Context) error
		}
	}
	lockRunInTx sync.RWMutex
}

// RunInTx calls RunInTxFunc.
func (mock *txManagerMock) RunInTx(ctx context.Context, fn func(ctx context.Context) error) error {
	if mock.RunInTxFunc == nil {
		panic("txManagerMock.RunInTxFunc: method is nil but txManager.RunInTx was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Fn  func(ctx context.Context) error
	}{
		Ctx: ctx,
		Fn:  fn,
	}
	mock.lockRunInTx.Lock()
	mock.calls.RunInTx = append(mock.calls.RunInTx, callInfo)
	mock.lockRunInTx.Unlock()
	return mock.RunInTxFunc(ctx, fn)
}

// RunInTxCalls gets all the calls that were made to RunInTx.
// Check the length with:
//
//	len(mockedtxManager.RunInTxCalls())
func (mock *txManagerMock) RunInTxCalls() []struct {
	Ctx context.Context
	Fn  func(ctx context.Context) error
} {
	var calls []struct {
		Ctx context.Context
		Fn  func(ctx context.Context) error
	}
	mock.lockRunInTx.RLock()
	calls = mock.calls.RunInTx
	mock.lockRunInTx.RUnlock()
	return calls
}
