// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlc

import (
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type AuditAction string

const (
	AuditActionCREATE AuditAction = "CREATE"
	AuditActionUPDATE AuditAction = "UPDATE"
	AuditActionDELETE AuditAction = "DELETE"
)

func (e *AuditAction) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AuditAction(s)
	case string:
		*e = AuditAction(s)
	default:
		return fmt.Errorf("unsupported scan type for AuditAction: %T", src)
	}
	return nil
}

type NullAuditAction struct {
	AuditAction AuditAction
	Valid       bool // Valid is true if AuditAction is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAuditAction) Scan(value interface{}) error {
	if value == nil {
		ns.AuditAction, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AuditAction.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAuditAction) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AuditAction), nil
}

type CardState string

const (
	CardStateNEW        CardState = "NEW"
	CardStateLEARNING   CardState = "LEARNING"
	CardStateREVIEW     CardState = "REVIEW"
	CardStateRELEARNING CardState = "RELEARNING"
)

func (e *CardState) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CardState(s)
	case string:
		*e = CardState(s)
	default:
		return fmt.Errorf("unsupported scan type for CardState: %T", src)
	}
	return nil
}

type NullCardState struct {
	CardState CardState
	Valid     bool // Valid is true if CardState is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCardState) Scan(value interface{}) error {
	if value == nil {
		ns.CardState, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CardState.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCardState) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CardState), nil
}

type EntityType string

const (
	EntityTypeENTRY         EntityType = "ENTRY"
	EntityTypeSENSE         EntityType = "SENSE"
	EntityTypeEXAMPLE       EntityType = "EXAMPLE"
	EntityTypeIMAGE         EntityType = "IMAGE"
	EntityTypePRONUNCIATION EntityType = "PRONUNCIATION"
	EntityTypeCARD          EntityType = "CARD"
	EntityTypeTOPIC         EntityType = "TOPIC"
	EntityTypeUSER          EntityType = "USER"
)

func (e *EntityType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EntityType(s)
	case string:
		*e = EntityType(s)
	default:
		return fmt.Errorf("unsupported scan type for EntityType: %T", src)
	}
	return nil
}

type NullEntityType struct {
	EntityType EntityType
	Valid      bool // Valid is true if EntityType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEntityType) Scan(value interface{}) error {
	if value == nil {
		ns.EntityType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EntityType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEntityType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EntityType), nil
}

type PartOfSpeech string

const (
	PartOfSpeechNOUN         PartOfSpeech = "NOUN"
	PartOfSpeechVERB         PartOfSpeech = "VERB"
	PartOfSpeechADJECTIVE    PartOfSpeech = "ADJECTIVE"
	PartOfSpeechADVERB       PartOfSpeech = "ADVERB"
	PartOfSpeechPRONOUN      PartOfSpeech = "PRONOUN"
	PartOfSpeechPREPOSITION  PartOfSpeech = "PREPOSITION"
	PartOfSpeechCONJUNCTION  PartOfSpeech = "CONJUNCTION"
	PartOfSpeechINTERJECTION PartOfSpeech = "INTERJECTION"
	PartOfSpeechPHRASE       PartOfSpeech = "PHRASE"
	PartOfSpeechIDIOM        PartOfSpeech = "IDIOM"
	PartOfSpeechOTHER        PartOfSpeech = "OTHER"
)

func (e *PartOfSpeech) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PartOfSpeech(s)
	case string:
		*e = PartOfSpeech(s)
	default:
		return fmt.Errorf("unsupported scan type for PartOfSpeech: %T", src)
	}
	return nil
}

type NullPartOfSpeech struct {
	PartOfSpeech PartOfSpeech
	Valid        bool // Valid is true if PartOfSpeech is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPartOfSpeech) Scan(value interface{}) error {
	if value == nil {
		ns.PartOfSpeech, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PartOfSpeech.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPartOfSpeech) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PartOfSpeech), nil
}

type ReviewGrade string

const (
	ReviewGradeAGAIN ReviewGrade = "AGAIN"
	ReviewGradeHARD  ReviewGrade = "HARD"
	ReviewGradeGOOD  ReviewGrade = "GOOD"
	ReviewGradeEASY  ReviewGrade = "EASY"
)

func (e *ReviewGrade) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ReviewGrade(s)
	case string:
		*e = ReviewGrade(s)
	default:
		return fmt.Errorf("unsupported scan type for ReviewGrade: %T", src)
	}
	return nil
}

type NullReviewGrade struct {
	ReviewGrade ReviewGrade
	Valid       bool // Valid is true if ReviewGrade is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullReviewGrade) Scan(value interface{}) error {
	if value == nil {
		ns.ReviewGrade, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ReviewGrade.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullReviewGrade) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ReviewGrade), nil
}

type AuditLog struct {
	ID         uuid.UUID
	UserID     uuid.UUID
	EntityType EntityType
	EntityID   pgtype.UUID
	Action     AuditAction
	Changes    []byte
	CreatedAt  time.Time
}

type AuthMethod struct {
	ID           uuid.UUID
	UserID       uuid.UUID
	Method       string
	ProviderID   pgtype.Text
	PasswordHash pgtype.Text
	CreatedAt    time.Time
	UpdatedAt    time.Time
}

type Card struct {
	ID            uuid.UUID
	UserID        uuid.UUID
	EntryID       uuid.UUID
	CreatedAt     time.Time
	UpdatedAt     time.Time
	State         CardState
	Step          int32
	Stability     float64
	Difficulty    float64
	Due           time.Time
	LastReview    *time.Time
	Reps          int32
	Lapses        int32
	ScheduledDays int32
	ElapsedDays   int32
}

type EnrichmentQueue struct {
	ID           uuid.UUID
	RefEntryID   uuid.UUID
	Status       string
	Priority     int32
	ErrorMessage pgtype.Text
	RequestedAt  time.Time
	ProcessedAt  *time.Time
	CreatedAt    time.Time
}

type Entry struct {
	ID             uuid.UUID
	UserID         uuid.UUID
	RefEntryID     pgtype.UUID
	Text           string
	TextNormalized string
	Notes          pgtype.Text
	CreatedAt      time.Time
	UpdatedAt      time.Time
	DeletedAt      *time.Time
}

type EntryImage struct {
	EntryID    uuid.UUID
	RefImageID uuid.UUID
}

type EntryPronunciation struct {
	EntryID            uuid.UUID
	RefPronunciationID uuid.UUID
}

type EntryTopic struct {
	EntryID uuid.UUID
	TopicID uuid.UUID
}

type Example struct {
	ID           uuid.UUID
	SenseID      uuid.UUID
	RefExampleID pgtype.UUID
	Sentence     pgtype.Text
	Translation  pgtype.Text
	SourceSlug   string
	Position     int32
	CreatedAt    time.Time
}

type InboxItem struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Text      string
	Context   pgtype.Text
	CreatedAt time.Time
}

type RefDataSource struct {
	Slug           string
	Name           string
	Description    pgtype.Text
	SourceType     string
	IsActive       pgtype.Bool
	DatasetVersion pgtype.Text
	CreatedAt      *time.Time
	UpdatedAt      *time.Time
}

type RefEntry struct {
	ID             uuid.UUID
	Text           string
	TextNormalized string
	CreatedAt      time.Time
	FrequencyRank  pgtype.Int4
	CefrLevel      pgtype.Text
	IsCoreLexicon  pgtype.Bool
}

type RefEntrySourceCoverage struct {
	RefEntryID     uuid.UUID
	SourceSlug     string
	Status         string
	DatasetVersion pgtype.Text
	FetchedAt      *time.Time
}

type RefExample struct {
	ID          uuid.UUID
	RefSenseID  uuid.UUID
	Sentence    string
	Translation pgtype.Text
	SourceSlug  string
	Position    int32
}

type RefImage struct {
	ID         uuid.UUID
	RefEntryID uuid.UUID
	Url        string
	Caption    pgtype.Text
	SourceSlug string
}

type RefPronunciation struct {
	ID            uuid.UUID
	RefEntryID    uuid.UUID
	Transcription string
	AudioUrl      pgtype.Text
	Region        pgtype.Text
	SourceSlug    string
}

type RefSense struct {
	ID           uuid.UUID
	RefEntryID   uuid.UUID
	Definition   pgtype.Text
	PartOfSpeech NullPartOfSpeech
	CefrLevel    pgtype.Text
	SourceSlug   string
	Position     int32
	CreatedAt    time.Time
	Notes        pgtype.Text
}

type RefTranslation struct {
	ID         uuid.UUID
	RefSenseID uuid.UUID
	Text       string
	SourceSlug string
	Position   int32
}

type RefWordRelation struct {
	ID            uuid.UUID
	SourceEntryID uuid.UUID
	TargetEntryID uuid.UUID
	RelationType  string
	SourceSlug    string
	CreatedAt     *time.Time
}

type RefreshToken struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	TokenHash string
	ExpiresAt time.Time
	CreatedAt time.Time
	RevokedAt *time.Time
}

type ReviewLog struct {
	ID         uuid.UUID
	CardID     uuid.UUID
	Grade      ReviewGrade
	PrevState  []byte
	DurationMs pgtype.Int4
	ReviewedAt time.Time
	UserID     uuid.UUID
}

type Sense struct {
	ID           uuid.UUID
	EntryID      uuid.UUID
	RefSenseID   pgtype.UUID
	Definition   pgtype.Text
	PartOfSpeech NullPartOfSpeech
	CefrLevel    pgtype.Text
	SourceSlug   string
	Position     int32
	CreatedAt    time.Time
}

type StudySession struct {
	ID         uuid.UUID
	UserID     uuid.UUID
	StartedAt  time.Time
	FinishedAt *time.Time
	Status     interface{}
	Result     []byte
	CreatedAt  time.Time
}

type Topic struct {
	ID          uuid.UUID
	UserID      uuid.UUID
	Name        string
	Description pgtype.Text
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

type Translation struct {
	ID               uuid.UUID
	SenseID          uuid.UUID
	RefTranslationID pgtype.UUID
	Text             pgtype.Text
	SourceSlug       string
	Position         int32
}

type User struct {
	ID        uuid.UUID
	Email     string
	Name      pgtype.Text
	AvatarUrl pgtype.Text
	CreatedAt time.Time
	UpdatedAt time.Time
	Username  string
	Role      string
}

type UserImage struct {
	ID        uuid.UUID
	EntryID   uuid.UUID
	Url       string
	Caption   pgtype.Text
	CreatedAt time.Time
}

type UserSetting struct {
	UserID           uuid.UUID
	NewCardsPerDay   int32
	ReviewsPerDay    int32
	MaxIntervalDays  int32
	Timezone         string
	UpdatedAt        time.Time
	DesiredRetention float64
}
