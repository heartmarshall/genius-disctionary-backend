// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: enrichment.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const claimBatch = `-- name: ClaimBatch :many
UPDATE enrichment_queue
SET status = 'processing'
WHERE id IN (
    SELECT id FROM enrichment_queue
    WHERE status = 'pending'
    ORDER BY priority DESC, requested_at
    LIMIT $1
    FOR UPDATE SKIP LOCKED
)
RETURNING id, ref_entry_id, status, priority, error_message, requested_at, processed_at, created_at
`

func (q *Queries) ClaimBatch(ctx context.Context, limit int32) ([]EnrichmentQueue, error) {
	rows, err := q.db.Query(ctx, claimBatch, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EnrichmentQueue{}
	for rows.Next() {
		var i EnrichmentQueue
		if err := rows.Scan(
			&i.ID,
			&i.RefEntryID,
			&i.Status,
			&i.Priority,
			&i.ErrorMessage,
			&i.RequestedAt,
			&i.ProcessedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const enqueue = `-- name: Enqueue :exec
INSERT INTO enrichment_queue (ref_entry_id, priority)
VALUES ($1, $2)
ON CONFLICT (ref_entry_id)
DO UPDATE SET priority = enrichment_queue.priority + 1,
              requested_at = now()
WHERE enrichment_queue.status IN ('pending', 'failed')
`

type EnqueueParams struct {
	RefEntryID uuid.UUID
	Priority   int32
}

func (q *Queries) Enqueue(ctx context.Context, arg EnqueueParams) error {
	_, err := q.db.Exec(ctx, enqueue, arg.RefEntryID, arg.Priority)
	return err
}

const getStats = `-- name: GetStats :one
SELECT
    count(*) FILTER (WHERE status = 'pending')    AS pending,
    count(*) FILTER (WHERE status = 'processing') AS processing,
    count(*) FILTER (WHERE status = 'done')        AS done,
    count(*) FILTER (WHERE status = 'failed')      AS failed,
    count(*)                                        AS total
FROM enrichment_queue
`

type GetStatsRow struct {
	Pending    int64
	Processing int64
	Done       int64
	Failed     int64
	Total      int64
}

func (q *Queries) GetStats(ctx context.Context) (GetStatsRow, error) {
	row := q.db.QueryRow(ctx, getStats)
	var i GetStatsRow
	err := row.Scan(
		&i.Pending,
		&i.Processing,
		&i.Done,
		&i.Failed,
		&i.Total,
	)
	return i, err
}

const list = `-- name: List :many
SELECT id, ref_entry_id, status, priority, error_message, requested_at, processed_at, created_at
FROM enrichment_queue
WHERE ($1::text = '' OR status = $1)
ORDER BY priority DESC, requested_at
LIMIT $2 OFFSET $3
`

type ListParams struct {
	Column1 string
	Limit   int32
	Offset  int32
}

func (q *Queries) List(ctx context.Context, arg ListParams) ([]EnrichmentQueue, error) {
	rows, err := q.db.Query(ctx, list, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EnrichmentQueue{}
	for rows.Next() {
		var i EnrichmentQueue
		if err := rows.Scan(
			&i.ID,
			&i.RefEntryID,
			&i.Status,
			&i.Priority,
			&i.ErrorMessage,
			&i.RequestedAt,
			&i.ProcessedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markDone = `-- name: MarkDone :exec
UPDATE enrichment_queue SET status = 'done', processed_at = now(), error_message = NULL
WHERE ref_entry_id = $1
`

func (q *Queries) MarkDone(ctx context.Context, refEntryID uuid.UUID) error {
	_, err := q.db.Exec(ctx, markDone, refEntryID)
	return err
}

const markFailed = `-- name: MarkFailed :exec
UPDATE enrichment_queue SET status = 'failed', processed_at = now(), error_message = $2
WHERE ref_entry_id = $1
`

type MarkFailedParams struct {
	RefEntryID   uuid.UUID
	ErrorMessage pgtype.Text
}

func (q *Queries) MarkFailed(ctx context.Context, arg MarkFailedParams) error {
	_, err := q.db.Exec(ctx, markFailed, arg.RefEntryID, arg.ErrorMessage)
	return err
}
