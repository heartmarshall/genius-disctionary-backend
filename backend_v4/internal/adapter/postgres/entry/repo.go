// Package entry implements the Entry repository using PostgreSQL.
// Static queries are generated by sqlc; the dynamic Find query uses Squirrel.
package entry

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"strings"
	"time"

	sq "github.com/Masterminds/squirrel"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"

	postgres "github.com/heartmarshall/myenglish-backend/internal/adapter/postgres"
	"github.com/heartmarshall/myenglish-backend/internal/adapter/postgres/entry/sqlc"
	"github.com/heartmarshall/myenglish-backend/internal/domain"
)

// psql is the Squirrel statement builder configured for PostgreSQL dollar placeholders.
var psql = sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

// FindResult holds the result of a Find query.
type FindResult struct {
	Entries     []domain.Entry
	TotalCount  int
	HasNextPage bool
}

// Repo provides entry persistence backed by PostgreSQL.
type Repo struct {
	pool *pgxpool.Pool
}

// New creates a new entry repository.
func New(pool *pgxpool.Pool) *Repo {
	return &Repo{pool: pool}
}

// ---------------------------------------------------------------------------
// Read operations
// ---------------------------------------------------------------------------

// GetByID returns a non-deleted entry by primary key.
func (r *Repo) GetByID(ctx context.Context, userID, id uuid.UUID) (domain.Entry, error) {
	q := sqlc.New(postgres.QuerierFromCtx(ctx, r.pool))

	row, err := q.GetEntryByID(ctx, sqlc.GetEntryByIDParams{
		ID:     id,
		UserID: userID,
	})
	if err != nil {
		return domain.Entry{}, mapError(err, "entry", id)
	}

	return toDomainEntry(row), nil
}

// GetByText returns a non-deleted entry by normalized text (for duplicate checking).
func (r *Repo) GetByText(ctx context.Context, userID uuid.UUID, textNormalized string) (domain.Entry, error) {
	q := sqlc.New(postgres.QuerierFromCtx(ctx, r.pool))

	row, err := q.GetEntryByText(ctx, sqlc.GetEntryByTextParams{
		UserID:         userID,
		TextNormalized: textNormalized,
	})
	if err != nil {
		return domain.Entry{}, mapError(err, "entry", uuid.Nil)
	}

	return toDomainEntry(row), nil
}

// GetByIDs returns non-deleted entries by a batch of IDs.
func (r *Repo) GetByIDs(ctx context.Context, userID uuid.UUID, ids []uuid.UUID) ([]domain.Entry, error) {
	if len(ids) == 0 {
		return []domain.Entry{}, nil
	}

	q := sqlc.New(postgres.QuerierFromCtx(ctx, r.pool))

	rows, err := q.GetEntriesByIDs(ctx, sqlc.GetEntriesByIDsParams{
		UserID: userID,
		Ids:    ids,
	})
	if err != nil {
		return nil, fmt.Errorf("get entries by ids: %w", err)
	}

	entries := make([]domain.Entry, len(rows))
	for i, row := range rows {
		entries[i] = toDomainEntry(row)
	}

	return entries, nil
}

// CountByUser returns the number of non-deleted entries for a user.
func (r *Repo) CountByUser(ctx context.Context, userID uuid.UUID) (int64, error) {
	q := sqlc.New(postgres.QuerierFromCtx(ctx, r.pool))

	count, err := q.CountEntriesByUser(ctx, userID)
	if err != nil {
		return 0, fmt.Errorf("count entries: %w", err)
	}

	return count, nil
}

// Find returns entries matching the given filter using dynamic SQL (Squirrel).
// Supports both offset-based and cursor-based pagination.
func (r *Repo) Find(ctx context.Context, userID uuid.UUID, f Filter) (FindResult, error) {
	f.normalize()

	querier := postgres.QuerierFromCtx(ctx, r.pool)

	// Build base WHERE conditions.
	baseWhere := buildBaseWhere(userID, f)

	// --- Count (only for offset mode) ---
	var totalCount int
	if !f.isCursor() {
		countQB := psql.Select("count(*)").From("entries").Where(baseWhere)
		countSQL, countArgs, err := countQB.ToSql()
		if err != nil {
			return FindResult{}, fmt.Errorf("build count query: %w", err)
		}

		if err := querier.QueryRow(ctx, countSQL, countArgs...).Scan(&totalCount); err != nil {
			return FindResult{}, fmt.Errorf("count entries: %w", err)
		}
	}

	// --- Data query ---
	cols := []string{
		"id", "user_id", "ref_entry_id", "text", "text_normalized",
		"notes", "created_at", "updated_at",
	}
	dataQB := psql.Select(cols...).From("entries").Where(baseWhere)

	// Cursor pagination: add keyset condition.
	if f.isCursor() {
		cursorWhere, err := decodeCursorWhere(f)
		if err != nil {
			return FindResult{}, err
		}
		dataQB = dataQB.Where(cursorWhere)
	}

	// Sorting.
	sortCol := f.sortColumn()
	orderDir := f.SortOrder
	dataQB = dataQB.OrderBy(sortCol + " " + orderDir + ", id " + orderDir)

	// Fetch limit+1 to detect hasNextPage in cursor mode.
	fetchLimit := f.Limit
	if f.isCursor() {
		fetchLimit = f.Limit + 1
	}
	dataQB = dataQB.Limit(uint64(fetchLimit))

	// Offset (only in offset mode).
	if !f.isCursor() && f.Offset > 0 {
		dataQB = dataQB.Offset(uint64(f.Offset))
	}

	dataSQL, dataArgs, err := dataQB.ToSql()
	if err != nil {
		return FindResult{}, fmt.Errorf("build data query: %w", err)
	}

	rows, err := querier.Query(ctx, dataSQL, dataArgs...)
	if err != nil {
		return FindResult{}, fmt.Errorf("find entries: %w", err)
	}
	defer rows.Close()

	var entries []domain.Entry
	for rows.Next() {
		var (
			id             uuid.UUID
			uid            uuid.UUID
			refEntryID     pgtype.UUID
			text           string
			textNormalized string
			notes          pgtype.Text
			createdAt      time.Time
			updatedAt      time.Time
		)
		if err := rows.Scan(&id, &uid, &refEntryID, &text, &textNormalized, &notes, &createdAt, &updatedAt); err != nil {
			return FindResult{}, fmt.Errorf("scan entry: %w", err)
		}

		e := domain.Entry{
			ID:             id,
			UserID:         uid,
			Text:           text,
			TextNormalized: textNormalized,
			CreatedAt:      createdAt,
			UpdatedAt:      updatedAt,
		}
		if refEntryID.Valid {
			rid := uuid.UUID(refEntryID.Bytes)
			e.RefEntryID = &rid
		}
		if notes.Valid {
			e.Notes = &notes.String
		}
		entries = append(entries, e)
	}
	if err := rows.Err(); err != nil {
		return FindResult{}, fmt.Errorf("iterate entries: %w", err)
	}

	if entries == nil {
		entries = []domain.Entry{}
	}

	// Determine hasNextPage for cursor mode.
	var hasNextPage bool
	if f.isCursor() && len(entries) > f.Limit {
		hasNextPage = true
		entries = entries[:f.Limit]
	}

	return FindResult{
		Entries:     entries,
		TotalCount:  totalCount,
		HasNextPage: hasNextPage,
	}, nil
}

// ---------------------------------------------------------------------------
// Write operations
// ---------------------------------------------------------------------------

// Create inserts a new entry and returns the persisted domain.Entry.
func (r *Repo) Create(ctx context.Context, userID uuid.UUID, e domain.Entry) (domain.Entry, error) {
	q := sqlc.New(postgres.QuerierFromCtx(ctx, r.pool))

	row, err := q.CreateEntry(ctx, sqlc.CreateEntryParams{
		ID:             e.ID,
		UserID:         userID,
		RefEntryID:     uuidPtrToPgtype(e.RefEntryID),
		Text:           e.Text,
		TextNormalized: e.TextNormalized,
		Notes:          ptrStringToPgText(e.Notes),
		CreatedAt:      e.CreatedAt,
		UpdatedAt:      e.UpdatedAt,
	})
	if err != nil {
		return domain.Entry{}, mapError(err, "entry", e.ID)
	}

	return toDomainEntry(row), nil
}

// UpdateNotes updates the notes field for a non-deleted entry.
func (r *Repo) UpdateNotes(ctx context.Context, userID, id uuid.UUID, notes *string) (domain.Entry, error) {
	q := sqlc.New(postgres.QuerierFromCtx(ctx, r.pool))

	row, err := q.UpdateEntryNotes(ctx, sqlc.UpdateEntryNotesParams{
		ID:     id,
		UserID: userID,
		Notes:  ptrStringToPgText(notes),
	})
	if err != nil {
		return domain.Entry{}, mapError(err, "entry", id)
	}

	return toDomainEntry(row), nil
}

// SoftDelete sets deleted_at on a non-deleted entry. Idempotent: if already
// soft-deleted, no error is returned.
func (r *Repo) SoftDelete(ctx context.Context, userID, id uuid.UUID) error {
	q := sqlc.New(postgres.QuerierFromCtx(ctx, r.pool))

	// SoftDeleteEntry updates WHERE deleted_at IS NULL.
	// If 0 rows affected, the entry either doesn't exist or is already deleted.
	// The spec says idempotent, so we don't error.
	return q.SoftDeleteEntry(ctx, sqlc.SoftDeleteEntryParams{
		ID:     id,
		UserID: userID,
	})
}

// Restore undeletes a soft-deleted entry.
func (r *Repo) Restore(ctx context.Context, userID, id uuid.UUID) (domain.Entry, error) {
	q := sqlc.New(postgres.QuerierFromCtx(ctx, r.pool))

	row, err := q.RestoreEntry(ctx, sqlc.RestoreEntryParams{
		ID:     id,
		UserID: userID,
	})
	if err != nil {
		return domain.Entry{}, mapError(err, "entry", id)
	}

	return toDomainEntry(row), nil
}

// HardDeleteOld permanently removes soft-deleted entries older than threshold.
// Deletes in batches of 100 to avoid long-running transactions.
// Returns the total number of deleted rows.
func (r *Repo) HardDeleteOld(ctx context.Context, threshold time.Time) (int64, error) {
	q := sqlc.New(postgres.QuerierFromCtx(ctx, r.pool))

	var total int64
	ts := &threshold
	for {
		n, err := q.HardDeleteOldEntries(ctx, ts)
		if err != nil {
			return total, fmt.Errorf("hard delete entries: %w", err)
		}
		total += n
		if n == 0 {
			break
		}
	}

	return total, nil
}

// ---------------------------------------------------------------------------
// Cursor encoding / decoding
// ---------------------------------------------------------------------------

// EncodeCursor produces a base64-encoded cursor from a sort value and entry ID.
func EncodeCursor(sortValue, entryID string) string {
	raw := sortValue + "|" + entryID
	return base64.StdEncoding.EncodeToString([]byte(raw))
}

// decodeCursor parses a base64 cursor into (sortValue, entryID).
func decodeCursor(cursor string) (string, uuid.UUID, error) {
	raw, err := base64.StdEncoding.DecodeString(cursor)
	if err != nil {
		return "", uuid.Nil, domain.NewValidationError("cursor", "invalid cursor encoding")
	}

	parts := strings.SplitN(string(raw), "|", 2)
	if len(parts) != 2 {
		return "", uuid.Nil, domain.NewValidationError("cursor", "invalid cursor format")
	}

	id, err := uuid.Parse(parts[1])
	if err != nil {
		return "", uuid.Nil, domain.NewValidationError("cursor", "invalid cursor entry ID")
	}

	return parts[0], id, nil
}

// decodeCursorWhere builds a Squirrel WHERE clause for keyset pagination.
func decodeCursorWhere(f Filter) (sq.Sqlizer, error) {
	sortValue, entryID, err := decodeCursor(*f.Cursor)
	if err != nil {
		return nil, err
	}

	col := f.sortColumn()
	op := ">"
	if f.SortOrder == sortOrderDESC {
		op = "<"
	}

	// Row-value comparison: (col, id) > ($1, $2) or (col, id) < ($1, $2).
	expr := fmt.Sprintf("(%s, id) %s (?, ?)", col, op)

	// For timestamp columns, parse the sort value as time.
	if col == "created_at" || col == "updated_at" {
		ts, err := time.Parse(time.RFC3339Nano, sortValue)
		if err != nil {
			return nil, domain.NewValidationError("cursor", "invalid cursor timestamp")
		}
		return sq.Expr(expr, ts, entryID), nil
	}

	// For text sort, use the string value directly.
	return sq.Expr(expr, sortValue, entryID), nil
}

// CursorFromEntry produces a cursor string from an entry and sort column.
func CursorFromEntry(e domain.Entry, sortBy string) string {
	var sortValue string
	switch sortBy {
	case sortByText:
		sortValue = e.TextNormalized
	case sortByUpdatedAt:
		sortValue = e.UpdatedAt.Format(time.RFC3339Nano)
	default:
		sortValue = e.CreatedAt.Format(time.RFC3339Nano)
	}
	return EncodeCursor(sortValue, e.ID.String())
}

// ---------------------------------------------------------------------------
// Dynamic WHERE builder (shared between count and data queries)
// ---------------------------------------------------------------------------

// buildBaseWhere constructs the shared WHERE conditions for Find.
func buildBaseWhere(userID uuid.UUID, f Filter) sq.And {
	where := sq.And{
		sq.Eq{"user_id": userID},
		sq.Expr("deleted_at IS NULL"),
	}

	if f.Search != nil && *f.Search != "" {
		where = append(where, sq.Expr("text_normalized ILIKE ?", "%"+*f.Search+"%"))
	}

	if f.HasCard != nil {
		if *f.HasCard {
			where = append(where, sq.Expr("EXISTS (SELECT 1 FROM cards WHERE cards.entry_id = entries.id)"))
		} else {
			where = append(where, sq.Expr("NOT EXISTS (SELECT 1 FROM cards WHERE cards.entry_id = entries.id)"))
		}
	}

	if f.PartOfSpeech != nil {
		where = append(where, sq.Expr(
			"EXISTS (SELECT 1 FROM senses s LEFT JOIN ref_senses rs ON s.ref_sense_id = rs.id WHERE s.entry_id = entries.id AND COALESCE(s.part_of_speech, rs.part_of_speech) = ?)",
			string(*f.PartOfSpeech),
		))
	}

	if f.TopicID != nil {
		where = append(where, sq.Expr(
			"EXISTS (SELECT 1 FROM entry_topics WHERE entry_topics.entry_id = entries.id AND entry_topics.topic_id = ?)",
			*f.TopicID,
		))
	}

	if f.Status != nil {
		where = append(where, sq.Expr(
			"EXISTS (SELECT 1 FROM cards WHERE cards.entry_id = entries.id AND cards.status = ?)",
			string(*f.Status),
		))
	}

	return where
}

// ---------------------------------------------------------------------------
// Error mapping
// ---------------------------------------------------------------------------

// mapError converts pgx/pgconn errors into domain errors.
func mapError(err error, entity string, id uuid.UUID) error {
	if err == nil {
		return nil
	}

	if errors.Is(err, context.DeadlineExceeded) || errors.Is(err, context.Canceled) {
		return fmt.Errorf("%s %s: %w", entity, id, err)
	}

	if errors.Is(err, pgx.ErrNoRows) {
		return fmt.Errorf("%s %s: %w", entity, id, domain.ErrNotFound)
	}

	var pgErr *pgconn.PgError
	if errors.As(err, &pgErr) {
		switch pgErr.Code {
		case "23505": // unique_violation
			return fmt.Errorf("%s %s: %w", entity, id, domain.ErrAlreadyExists)
		case "23503": // foreign_key_violation
			return fmt.Errorf("%s %s: %w", entity, id, domain.ErrNotFound)
		case "23514": // check_violation
			return fmt.Errorf("%s %s: %w", entity, id, domain.ErrValidation)
		}
	}

	return fmt.Errorf("%s %s: %w", entity, id, err)
}

// ---------------------------------------------------------------------------
// Mapping helpers: sqlc -> domain
// ---------------------------------------------------------------------------

// toDomainEntry converts a sqlc.Entry row into a domain.Entry.
func toDomainEntry(row sqlc.Entry) domain.Entry {
	e := domain.Entry{
		ID:             row.ID,
		UserID:         row.UserID,
		Text:           row.Text,
		TextNormalized: row.TextNormalized,
		CreatedAt:      row.CreatedAt,
		UpdatedAt:      row.UpdatedAt,
		DeletedAt:      row.DeletedAt,
	}

	if row.RefEntryID.Valid {
		rid := uuid.UUID(row.RefEntryID.Bytes)
		e.RefEntryID = &rid
	}

	if row.Notes.Valid {
		e.Notes = &row.Notes.String
	}

	return e
}

// ---------------------------------------------------------------------------
// pgtype helpers
// ---------------------------------------------------------------------------

// ptrStringToPgText converts a *string to pgtype.Text (nil -> NULL).
func ptrStringToPgText(s *string) pgtype.Text {
	if s == nil {
		return pgtype.Text{}
	}
	return pgtype.Text{String: *s, Valid: true}
}

// uuidPtrToPgtype converts a *uuid.UUID to pgtype.UUID.
func uuidPtrToPgtype(id *uuid.UUID) pgtype.UUID {
	if id == nil {
		return pgtype.UUID{}
	}
	return pgtype.UUID{Bytes: *id, Valid: true}
}
