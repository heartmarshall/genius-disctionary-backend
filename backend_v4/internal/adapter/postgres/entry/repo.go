// Package entry implements the Entry repository using PostgreSQL.
// Static queries are generated by sqlc; the dynamic Find query uses Squirrel.
package entry

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"strings"
	"time"

	sq "github.com/Masterminds/squirrel"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"

	postgres "github.com/heartmarshall/myenglish-backend/internal/adapter/postgres"
	"github.com/heartmarshall/myenglish-backend/internal/adapter/postgres/entry/sqlc"
	"github.com/heartmarshall/myenglish-backend/internal/domain"
)

// psql is the Squirrel statement builder configured for PostgreSQL dollar placeholders.
var psql = sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

const (
	defaultLimit = 50
	maxLimit     = 200

	sortByText      = "text"
	sortByCreatedAt = "created_at"
	sortByUpdatedAt = "updated_at"

	sortOrderASC  = "ASC"
	sortOrderDESC = "DESC"
)

// Repo provides entry persistence backed by PostgreSQL.
type Repo struct {
	pool *pgxpool.Pool
}

// New creates a new entry repository.
func New(pool *pgxpool.Pool) *Repo {
	return &Repo{pool: pool}
}

// ---------------------------------------------------------------------------
// Read operations
// ---------------------------------------------------------------------------

// GetByID returns a non-deleted entry by primary key.
func (r *Repo) GetByID(ctx context.Context, userID, id uuid.UUID) (*domain.Entry, error) {
	q := sqlc.New(postgres.QuerierFromCtx(ctx, r.pool))

	row, err := q.GetEntryByID(ctx, sqlc.GetEntryByIDParams{
		ID:     id,
		UserID: userID,
	})
	if err != nil {
		return nil, mapError(err, "entry", id)
	}

	e := toDomainEntry(row)
	return &e, nil
}

// GetByText returns a non-deleted entry by normalized text (for duplicate checking).
func (r *Repo) GetByText(ctx context.Context, userID uuid.UUID, textNormalized string) (*domain.Entry, error) {
	q := sqlc.New(postgres.QuerierFromCtx(ctx, r.pool))

	row, err := q.GetEntryByText(ctx, sqlc.GetEntryByTextParams{
		UserID:         userID,
		TextNormalized: textNormalized,
	})
	if err != nil {
		return nil, mapError(err, "entry", uuid.Nil)
	}

	e := toDomainEntry(row)
	return &e, nil
}

// GetByIDs returns non-deleted entries by a batch of IDs.
func (r *Repo) GetByIDs(ctx context.Context, userID uuid.UUID, ids []uuid.UUID) ([]domain.Entry, error) {
	if len(ids) == 0 {
		return []domain.Entry{}, nil
	}

	q := sqlc.New(postgres.QuerierFromCtx(ctx, r.pool))

	rows, err := q.GetEntriesByIDs(ctx, sqlc.GetEntriesByIDsParams{
		UserID: userID,
		Ids:    ids,
	})
	if err != nil {
		return nil, fmt.Errorf("get entries by ids: %w", err)
	}

	entries := make([]domain.Entry, len(rows))
	for i, row := range rows {
		entries[i] = toDomainEntry(row)
	}

	return entries, nil
}

// CountByUser returns the number of non-deleted entries for a user.
func (r *Repo) CountByUser(ctx context.Context, userID uuid.UUID) (int, error) {
	q := sqlc.New(postgres.QuerierFromCtx(ctx, r.pool))

	count, err := q.CountEntriesByUser(ctx, userID)
	if err != nil {
		return 0, fmt.Errorf("count entries: %w", err)
	}

	return int(count), nil
}

// ExistByIDs checks which of the given IDs exist as non-deleted entries for a user.
// Returns a map of id -> true for each existing entry.
func (r *Repo) ExistByIDs(ctx context.Context, userID uuid.UUID, ids []uuid.UUID) (map[uuid.UUID]bool, error) {
	if len(ids) == 0 {
		return map[uuid.UUID]bool{}, nil
	}

	querier := postgres.QuerierFromCtx(ctx, r.pool)

	query, args, err := psql.
		Select("id").
		From("entries").
		Where(sq.Eq{"user_id": userID}).
		Where(sq.Eq{"id": ids}).
		Where(sq.Expr("deleted_at IS NULL")).
		ToSql()
	if err != nil {
		return nil, fmt.Errorf("build exist by ids query: %w", err)
	}

	rows, err := querier.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("exist by ids: %w", err)
	}
	defer rows.Close()

	result := make(map[uuid.UUID]bool, len(ids))
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, fmt.Errorf("scan entry id: %w", err)
		}
		result[id] = true
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("iterate entry ids: %w", err)
	}

	return result, nil
}

// Find returns entries matching the given filter using offset-based pagination.
// Always runs a COUNT query and returns (entries, totalCount, error).
func (r *Repo) Find(ctx context.Context, userID uuid.UUID, f domain.EntryFilter) ([]domain.Entry, int, error) {
	normalizeFilter(&f)

	querier := postgres.QuerierFromCtx(ctx, r.pool)

	// Build base WHERE conditions.
	baseWhere := buildBaseWhere(userID, f)

	// --- Count ---
	var totalCount int
	countQB := psql.Select("count(*)").From("entries").Where(baseWhere)
	countSQL, countArgs, err := countQB.ToSql()
	if err != nil {
		return nil, 0, fmt.Errorf("build count query: %w", err)
	}

	if err := querier.QueryRow(ctx, countSQL, countArgs...).Scan(&totalCount); err != nil {
		return nil, 0, fmt.Errorf("count entries: %w", err)
	}

	// --- Data query ---
	cols := []string{
		"id", "user_id", "ref_entry_id", "text", "text_normalized",
		"notes", "created_at", "updated_at",
	}
	dataQB := psql.Select(cols...).From("entries").Where(baseWhere)

	// Sorting.
	sortCol := sortColumn(f.SortBy)
	orderDir := f.SortOrder
	dataQB = dataQB.OrderBy(sortCol + " " + orderDir + ", id " + orderDir)

	// Limit.
	dataQB = dataQB.Limit(uint64(f.Limit))

	// Offset.
	if f.Offset != nil && *f.Offset > 0 {
		dataQB = dataQB.Offset(uint64(*f.Offset))
	}

	entries, err := scanEntries(ctx, querier, dataQB)
	if err != nil {
		return nil, 0, err
	}

	return entries, totalCount, nil
}

// FindCursor returns entries matching the given filter using cursor-based pagination.
// Fetches limit+1 to detect hasNextPage. Returns (entries, hasNextPage, error).
func (r *Repo) FindCursor(ctx context.Context, userID uuid.UUID, f domain.EntryFilter) ([]domain.Entry, bool, error) {
	normalizeFilter(&f)

	querier := postgres.QuerierFromCtx(ctx, r.pool)

	// Build base WHERE conditions.
	baseWhere := buildBaseWhere(userID, f)

	// --- Data query ---
	cols := []string{
		"id", "user_id", "ref_entry_id", "text", "text_normalized",
		"notes", "created_at", "updated_at",
	}
	dataQB := psql.Select(cols...).From("entries").Where(baseWhere)

	// Cursor pagination: add keyset condition.
	if f.Cursor != nil {
		cursorWhere, err := decodeCursorWhere(f)
		if err != nil {
			return nil, false, err
		}
		dataQB = dataQB.Where(cursorWhere)
	}

	// Sorting.
	sortCol := sortColumn(f.SortBy)
	orderDir := f.SortOrder
	dataQB = dataQB.OrderBy(sortCol + " " + orderDir + ", id " + orderDir)

	// Fetch limit+1 to detect hasNextPage.
	fetchLimit := f.Limit + 1
	dataQB = dataQB.Limit(uint64(fetchLimit))

	entries, err := scanEntries(ctx, querier, dataQB)
	if err != nil {
		return nil, false, err
	}

	// Determine hasNextPage.
	var hasNextPage bool
	if len(entries) > f.Limit {
		hasNextPage = true
		entries = entries[:f.Limit]
	}

	return entries, hasNextPage, nil
}

// FindDeleted returns soft-deleted entries for a user with offset-based pagination.
// Returns (entries, totalCount, error).
func (r *Repo) FindDeleted(ctx context.Context, userID uuid.UUID, limit, offset int) ([]domain.Entry, int, error) {
	querier := postgres.QuerierFromCtx(ctx, r.pool)

	baseWhere := sq.And{
		sq.Eq{"user_id": userID},
		sq.Expr("deleted_at IS NOT NULL"),
	}

	// --- Count ---
	var totalCount int
	countQB := psql.Select("count(*)").From("entries").Where(baseWhere)
	countSQL, countArgs, err := countQB.ToSql()
	if err != nil {
		return nil, 0, fmt.Errorf("build count query: %w", err)
	}

	if err := querier.QueryRow(ctx, countSQL, countArgs...).Scan(&totalCount); err != nil {
		return nil, 0, fmt.Errorf("count deleted entries: %w", err)
	}

	// --- Data query ---
	cols := []string{
		"id", "user_id", "ref_entry_id", "text", "text_normalized",
		"notes", "created_at", "updated_at", "deleted_at",
	}
	dataQB := psql.Select(cols...).From("entries").Where(baseWhere).
		OrderBy("deleted_at DESC").
		Limit(uint64(limit))

	if offset > 0 {
		dataQB = dataQB.Offset(uint64(offset))
	}

	dataSQL, dataArgs, err := dataQB.ToSql()
	if err != nil {
		return nil, 0, fmt.Errorf("build find deleted query: %w", err)
	}

	rows, err := querier.Query(ctx, dataSQL, dataArgs...)
	if err != nil {
		return nil, 0, fmt.Errorf("find deleted entries: %w", err)
	}
	defer rows.Close()

	var entries []domain.Entry
	for rows.Next() {
		var (
			id             uuid.UUID
			uid            uuid.UUID
			refEntryID     pgtype.UUID
			text           string
			textNormalized string
			notes          pgtype.Text
			createdAt      time.Time
			updatedAt      time.Time
			deletedAt      *time.Time
		)
		if err := rows.Scan(&id, &uid, &refEntryID, &text, &textNormalized, &notes, &createdAt, &updatedAt, &deletedAt); err != nil {
			return nil, 0, fmt.Errorf("scan deleted entry: %w", err)
		}

		e := domain.Entry{
			ID:             id,
			UserID:         uid,
			Text:           text,
			TextNormalized: textNormalized,
			CreatedAt:      createdAt,
			UpdatedAt:      updatedAt,
			DeletedAt:      deletedAt,
		}
		if refEntryID.Valid {
			rid := uuid.UUID(refEntryID.Bytes)
			e.RefEntryID = &rid
		}
		if notes.Valid {
			e.Notes = &notes.String
		}
		entries = append(entries, e)
	}
	if err := rows.Err(); err != nil {
		return nil, 0, fmt.Errorf("iterate deleted entries: %w", err)
	}

	if entries == nil {
		entries = []domain.Entry{}
	}

	return entries, totalCount, nil
}

// ---------------------------------------------------------------------------
// Write operations
// ---------------------------------------------------------------------------

// Create inserts a new entry and returns the persisted domain.Entry.
func (r *Repo) Create(ctx context.Context, entry *domain.Entry) (*domain.Entry, error) {
	q := sqlc.New(postgres.QuerierFromCtx(ctx, r.pool))

	row, err := q.CreateEntry(ctx, sqlc.CreateEntryParams{
		ID:             entry.ID,
		UserID:         entry.UserID,
		RefEntryID:     uuidPtrToPgtype(entry.RefEntryID),
		Text:           entry.Text,
		TextNormalized: entry.TextNormalized,
		Notes:          ptrStringToPgText(entry.Notes),
		CreatedAt:      entry.CreatedAt,
		UpdatedAt:      entry.UpdatedAt,
	})
	if err != nil {
		return nil, mapError(err, "entry", entry.ID)
	}

	e := toDomainEntry(row)
	return &e, nil
}

// UpdateNotes updates the notes field for a non-deleted entry.
func (r *Repo) UpdateNotes(ctx context.Context, userID, id uuid.UUID, notes *string) (*domain.Entry, error) {
	q := sqlc.New(postgres.QuerierFromCtx(ctx, r.pool))

	row, err := q.UpdateEntryNotes(ctx, sqlc.UpdateEntryNotesParams{
		ID:     id,
		UserID: userID,
		Notes:  ptrStringToPgText(notes),
	})
	if err != nil {
		return nil, mapError(err, "entry", id)
	}

	e := toDomainEntry(row)
	return &e, nil
}

// SoftDelete sets deleted_at on a non-deleted entry. Idempotent: if already
// soft-deleted, no error is returned.
func (r *Repo) SoftDelete(ctx context.Context, userID, id uuid.UUID) error {
	q := sqlc.New(postgres.QuerierFromCtx(ctx, r.pool))

	// SoftDeleteEntry updates WHERE deleted_at IS NULL.
	// If 0 rows affected, the entry either doesn't exist or is already deleted.
	// The spec says idempotent, so we don't error.
	return q.SoftDeleteEntry(ctx, sqlc.SoftDeleteEntryParams{
		ID:     id,
		UserID: userID,
	})
}

// Restore undeletes a soft-deleted entry.
func (r *Repo) Restore(ctx context.Context, userID, id uuid.UUID) (*domain.Entry, error) {
	q := sqlc.New(postgres.QuerierFromCtx(ctx, r.pool))

	row, err := q.RestoreEntry(ctx, sqlc.RestoreEntryParams{
		ID:     id,
		UserID: userID,
	})
	if err != nil {
		return nil, mapError(err, "entry", id)
	}

	e := toDomainEntry(row)
	return &e, nil
}

// HardDeleteOld permanently removes soft-deleted entries older than threshold.
// Deletes in batches of 100 to avoid long-running transactions.
// Returns the total number of deleted rows.
func (r *Repo) HardDeleteOld(ctx context.Context, threshold time.Time) (int64, error) {
	q := sqlc.New(postgres.QuerierFromCtx(ctx, r.pool))

	var total int64
	ts := &threshold
	for {
		n, err := q.HardDeleteOldEntries(ctx, ts)
		if err != nil {
			return total, fmt.Errorf("hard delete entries: %w", err)
		}
		total += n
		if n == 0 {
			break
		}
	}

	return total, nil
}

// ---------------------------------------------------------------------------
// Cursor encoding / decoding
// ---------------------------------------------------------------------------

// EncodeCursor produces a base64-encoded cursor from a sort value and entry ID.
func EncodeCursor(sortValue, entryID string) string {
	raw := sortValue + "|" + entryID
	return base64.StdEncoding.EncodeToString([]byte(raw))
}

// decodeCursor parses a base64 cursor into (sortValue, entryID).
func decodeCursor(cursor string) (string, uuid.UUID, error) {
	raw, err := base64.StdEncoding.DecodeString(cursor)
	if err != nil {
		return "", uuid.Nil, domain.NewValidationError("cursor", "invalid cursor encoding")
	}

	parts := strings.SplitN(string(raw), "|", 2)
	if len(parts) != 2 {
		return "", uuid.Nil, domain.NewValidationError("cursor", "invalid cursor format")
	}

	id, err := uuid.Parse(parts[1])
	if err != nil {
		return "", uuid.Nil, domain.NewValidationError("cursor", "invalid cursor entry ID")
	}

	return parts[0], id, nil
}

// decodeCursorWhere builds a Squirrel WHERE clause for keyset pagination.
func decodeCursorWhere(f domain.EntryFilter) (sq.Sqlizer, error) {
	sortValue, entryID, err := decodeCursor(*f.Cursor)
	if err != nil {
		return nil, err
	}

	col := sortColumn(f.SortBy)
	op := ">"
	if f.SortOrder == sortOrderDESC {
		op = "<"
	}

	// Row-value comparison: (col, id) > ($1, $2) or (col, id) < ($1, $2).
	expr := fmt.Sprintf("(%s, id) %s (?, ?)", col, op)

	// For timestamp columns, parse the sort value as time.
	if col == "created_at" || col == "updated_at" {
		ts, err := time.Parse(time.RFC3339Nano, sortValue)
		if err != nil {
			return nil, domain.NewValidationError("cursor", "invalid cursor timestamp")
		}
		return sq.Expr(expr, ts, entryID), nil
	}

	// For text sort, use the string value directly.
	return sq.Expr(expr, sortValue, entryID), nil
}

// CursorFromEntry produces a cursor string from an entry and sort column.
func CursorFromEntry(e domain.Entry, sortBy string) string {
	var sortValue string
	switch sortBy {
	case sortByText:
		sortValue = e.TextNormalized
	case sortByUpdatedAt:
		sortValue = e.UpdatedAt.Format(time.RFC3339Nano)
	default:
		sortValue = e.CreatedAt.Format(time.RFC3339Nano)
	}
	return EncodeCursor(sortValue, e.ID.String())
}

// ---------------------------------------------------------------------------
// Filter normalization
// ---------------------------------------------------------------------------

// normalizeFilter applies defaults and clamps values to a domain.EntryFilter.
func normalizeFilter(f *domain.EntryFilter) {
	// Sort column.
	switch f.SortBy {
	case sortByText, sortByCreatedAt, sortByUpdatedAt:
		// valid
	default:
		f.SortBy = sortByCreatedAt
	}

	// Sort order.
	switch f.SortOrder {
	case sortOrderASC, sortOrderDESC:
		// valid
	default:
		f.SortOrder = sortOrderDESC
	}

	// Limit.
	if f.Limit <= 0 {
		f.Limit = defaultLimit
	}
	if f.Limit > maxLimit {
		f.Limit = maxLimit
	}
}

// sortColumn returns the SQL column name for the given SortBy value.
func sortColumn(sortBy string) string {
	switch sortBy {
	case sortByText:
		return "text_normalized"
	case sortByUpdatedAt:
		return "updated_at"
	default:
		return "created_at"
	}
}

// ---------------------------------------------------------------------------
// Dynamic WHERE builder (shared between count and data queries)
// ---------------------------------------------------------------------------

// buildBaseWhere constructs the shared WHERE conditions for Find.
func buildBaseWhere(userID uuid.UUID, f domain.EntryFilter) sq.And {
	where := sq.And{
		sq.Eq{"user_id": userID},
		sq.Expr("deleted_at IS NULL"),
	}

	if f.Search != nil && *f.Search != "" {
		where = append(where, sq.Expr("text_normalized ILIKE ?", "%"+*f.Search+"%"))
	}

	if f.HasCard != nil {
		if *f.HasCard {
			where = append(where, sq.Expr("EXISTS (SELECT 1 FROM cards WHERE cards.entry_id = entries.id)"))
		} else {
			where = append(where, sq.Expr("NOT EXISTS (SELECT 1 FROM cards WHERE cards.entry_id = entries.id)"))
		}
	}

	if f.PartOfSpeech != nil {
		where = append(where, sq.Expr(
			"EXISTS (SELECT 1 FROM senses s LEFT JOIN ref_senses rs ON s.ref_sense_id = rs.id WHERE s.entry_id = entries.id AND COALESCE(s.part_of_speech, rs.part_of_speech) = ?)",
			string(*f.PartOfSpeech),
		))
	}

	if f.TopicID != nil {
		where = append(where, sq.Expr(
			"EXISTS (SELECT 1 FROM entry_topics WHERE entry_topics.entry_id = entries.id AND entry_topics.topic_id = ?)",
			*f.TopicID,
		))
	}

	if f.Status != nil {
		where = append(where, sq.Expr(
			"EXISTS (SELECT 1 FROM cards WHERE cards.entry_id = entries.id AND cards.state = ?)",
			string(*f.Status),
		))
	}

	return where
}

// ---------------------------------------------------------------------------
// scanEntries scans entry rows from a Squirrel query builder.
// ---------------------------------------------------------------------------

func scanEntries(ctx context.Context, querier postgres.Querier, qb sq.SelectBuilder) ([]domain.Entry, error) {
	dataSQL, dataArgs, err := qb.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build data query: %w", err)
	}

	rows, err := querier.Query(ctx, dataSQL, dataArgs...)
	if err != nil {
		return nil, fmt.Errorf("find entries: %w", err)
	}
	defer rows.Close()

	var entries []domain.Entry
	for rows.Next() {
		var (
			id             uuid.UUID
			uid            uuid.UUID
			refEntryID     pgtype.UUID
			text           string
			textNormalized string
			notes          pgtype.Text
			createdAt      time.Time
			updatedAt      time.Time
		)
		if err := rows.Scan(&id, &uid, &refEntryID, &text, &textNormalized, &notes, &createdAt, &updatedAt); err != nil {
			return nil, fmt.Errorf("scan entry: %w", err)
		}

		e := domain.Entry{
			ID:             id,
			UserID:         uid,
			Text:           text,
			TextNormalized: textNormalized,
			CreatedAt:      createdAt,
			UpdatedAt:      updatedAt,
		}
		if refEntryID.Valid {
			rid := uuid.UUID(refEntryID.Bytes)
			e.RefEntryID = &rid
		}
		if notes.Valid {
			e.Notes = &notes.String
		}
		entries = append(entries, e)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("iterate entries: %w", err)
	}

	if entries == nil {
		entries = []domain.Entry{}
	}

	return entries, nil
}

// ---------------------------------------------------------------------------
// Error mapping
// ---------------------------------------------------------------------------

// mapError converts pgx/pgconn errors into domain errors.
func mapError(err error, entity string, id uuid.UUID) error {
	if err == nil {
		return nil
	}

	if errors.Is(err, context.DeadlineExceeded) || errors.Is(err, context.Canceled) {
		return fmt.Errorf("%s %s: %w", entity, id, err)
	}

	if errors.Is(err, pgx.ErrNoRows) {
		return fmt.Errorf("%s %s: %w", entity, id, domain.ErrNotFound)
	}

	var pgErr *pgconn.PgError
	if errors.As(err, &pgErr) {
		switch pgErr.Code {
		case "23505": // unique_violation
			return fmt.Errorf("%s %s: %w", entity, id, domain.ErrAlreadyExists)
		case "23503": // foreign_key_violation
			return fmt.Errorf("%s %s: %w", entity, id, domain.ErrNotFound)
		case "23514": // check_violation
			return fmt.Errorf("%s %s: %w", entity, id, domain.ErrValidation)
		}
	}

	return fmt.Errorf("%s %s: %w", entity, id, err)
}

// ---------------------------------------------------------------------------
// Mapping helpers: sqlc -> domain
// ---------------------------------------------------------------------------

// toDomainEntry converts a sqlc.Entry row into a domain.Entry.
func toDomainEntry(row sqlc.Entry) domain.Entry {
	e := domain.Entry{
		ID:             row.ID,
		UserID:         row.UserID,
		Text:           row.Text,
		TextNormalized: row.TextNormalized,
		CreatedAt:      row.CreatedAt,
		UpdatedAt:      row.UpdatedAt,
		DeletedAt:      row.DeletedAt,
	}

	if row.RefEntryID.Valid {
		rid := uuid.UUID(row.RefEntryID.Bytes)
		e.RefEntryID = &rid
	}

	if row.Notes.Valid {
		e.Notes = &row.Notes.String
	}

	return e
}

// ---------------------------------------------------------------------------
// pgtype helpers
// ---------------------------------------------------------------------------

// ptrStringToPgText converts a *string to pgtype.Text (nil -> NULL).
func ptrStringToPgText(s *string) pgtype.Text {
	if s == nil {
		return pgtype.Text{}
	}
	return pgtype.Text{String: *s, Valid: true}
}

// uuidPtrToPgtype converts a *uuid.UUID to pgtype.UUID.
func uuidPtrToPgtype(id *uuid.UUID) pgtype.UUID {
	if id == nil {
		return pgtype.UUID{}
	}
	return pgtype.UUID{Bytes: *id, Valid: true}
}
