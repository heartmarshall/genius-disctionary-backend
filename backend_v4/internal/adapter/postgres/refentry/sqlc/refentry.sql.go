// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: refentry.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getRefEntryByID = `-- name: GetRefEntryByID :one

SELECT id, text, text_normalized, created_at
FROM ref_entries
WHERE id = $1
`

// ---------------------------------------------------------------------------
// ref_entries
// ---------------------------------------------------------------------------
func (q *Queries) GetRefEntryByID(ctx context.Context, id uuid.UUID) (RefEntry, error) {
	row := q.db.QueryRow(ctx, getRefEntryByID, id)
	var i RefEntry
	err := row.Scan(
		&i.ID,
		&i.Text,
		&i.TextNormalized,
		&i.CreatedAt,
	)
	return i, err
}

const getRefEntryByNormalizedText = `-- name: GetRefEntryByNormalizedText :one
SELECT id, text, text_normalized, created_at
FROM ref_entries
WHERE text_normalized = $1
`

func (q *Queries) GetRefEntryByNormalizedText(ctx context.Context, textNormalized string) (RefEntry, error) {
	row := q.db.QueryRow(ctx, getRefEntryByNormalizedText, textNormalized)
	var i RefEntry
	err := row.Scan(
		&i.ID,
		&i.Text,
		&i.TextNormalized,
		&i.CreatedAt,
	)
	return i, err
}

const getRefExamplesByIDs = `-- name: GetRefExamplesByIDs :many
SELECT id, ref_sense_id, sentence, translation, source_slug, position
FROM ref_examples
WHERE id = ANY($1::uuid[])
ORDER BY position
`

func (q *Queries) GetRefExamplesByIDs(ctx context.Context, ids []uuid.UUID) ([]RefExample, error) {
	rows, err := q.db.Query(ctx, getRefExamplesByIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RefExample{}
	for rows.Next() {
		var i RefExample
		if err := rows.Scan(
			&i.ID,
			&i.RefSenseID,
			&i.Sentence,
			&i.Translation,
			&i.SourceSlug,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRefExamplesBySenseIDs = `-- name: GetRefExamplesBySenseIDs :many

SELECT id, ref_sense_id, sentence, translation, source_slug, position
FROM ref_examples
WHERE ref_sense_id = ANY($1::uuid[])
ORDER BY position
`

// ---------------------------------------------------------------------------
// ref_examples
// ---------------------------------------------------------------------------
func (q *Queries) GetRefExamplesBySenseIDs(ctx context.Context, senseIds []uuid.UUID) ([]RefExample, error) {
	rows, err := q.db.Query(ctx, getRefExamplesBySenseIDs, senseIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RefExample{}
	for rows.Next() {
		var i RefExample
		if err := rows.Scan(
			&i.ID,
			&i.RefSenseID,
			&i.Sentence,
			&i.Translation,
			&i.SourceSlug,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRefImagesByEntryID = `-- name: GetRefImagesByEntryID :many

SELECT id, ref_entry_id, url, caption, source_slug
FROM ref_images
WHERE ref_entry_id = $1
`

// ---------------------------------------------------------------------------
// ref_images
// ---------------------------------------------------------------------------
func (q *Queries) GetRefImagesByEntryID(ctx context.Context, refEntryID uuid.UUID) ([]RefImage, error) {
	rows, err := q.db.Query(ctx, getRefImagesByEntryID, refEntryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RefImage{}
	for rows.Next() {
		var i RefImage
		if err := rows.Scan(
			&i.ID,
			&i.RefEntryID,
			&i.Url,
			&i.Caption,
			&i.SourceSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRefImagesByIDs = `-- name: GetRefImagesByIDs :many
SELECT id, ref_entry_id, url, caption, source_slug
FROM ref_images
WHERE id = ANY($1::uuid[])
`

func (q *Queries) GetRefImagesByIDs(ctx context.Context, ids []uuid.UUID) ([]RefImage, error) {
	rows, err := q.db.Query(ctx, getRefImagesByIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RefImage{}
	for rows.Next() {
		var i RefImage
		if err := rows.Scan(
			&i.ID,
			&i.RefEntryID,
			&i.Url,
			&i.Caption,
			&i.SourceSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRefPronunciationsByEntryID = `-- name: GetRefPronunciationsByEntryID :many

SELECT id, ref_entry_id, transcription, audio_url, region, source_slug
FROM ref_pronunciations
WHERE ref_entry_id = $1
`

// ---------------------------------------------------------------------------
// ref_pronunciations
// ---------------------------------------------------------------------------
func (q *Queries) GetRefPronunciationsByEntryID(ctx context.Context, refEntryID uuid.UUID) ([]RefPronunciation, error) {
	rows, err := q.db.Query(ctx, getRefPronunciationsByEntryID, refEntryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RefPronunciation{}
	for rows.Next() {
		var i RefPronunciation
		if err := rows.Scan(
			&i.ID,
			&i.RefEntryID,
			&i.Transcription,
			&i.AudioUrl,
			&i.Region,
			&i.SourceSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRefPronunciationsByIDs = `-- name: GetRefPronunciationsByIDs :many
SELECT id, ref_entry_id, transcription, audio_url, region, source_slug
FROM ref_pronunciations
WHERE id = ANY($1::uuid[])
`

func (q *Queries) GetRefPronunciationsByIDs(ctx context.Context, ids []uuid.UUID) ([]RefPronunciation, error) {
	rows, err := q.db.Query(ctx, getRefPronunciationsByIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RefPronunciation{}
	for rows.Next() {
		var i RefPronunciation
		if err := rows.Scan(
			&i.ID,
			&i.RefEntryID,
			&i.Transcription,
			&i.AudioUrl,
			&i.Region,
			&i.SourceSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRefSensesByEntryID = `-- name: GetRefSensesByEntryID :many

SELECT id, ref_entry_id, definition, part_of_speech, cefr_level, source_slug, position, created_at
FROM ref_senses
WHERE ref_entry_id = $1
ORDER BY position
`

// ---------------------------------------------------------------------------
// ref_senses
// ---------------------------------------------------------------------------
func (q *Queries) GetRefSensesByEntryID(ctx context.Context, refEntryID uuid.UUID) ([]RefSense, error) {
	rows, err := q.db.Query(ctx, getRefSensesByEntryID, refEntryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RefSense{}
	for rows.Next() {
		var i RefSense
		if err := rows.Scan(
			&i.ID,
			&i.RefEntryID,
			&i.Definition,
			&i.PartOfSpeech,
			&i.CefrLevel,
			&i.SourceSlug,
			&i.Position,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRefSensesByIDs = `-- name: GetRefSensesByIDs :many
SELECT id, ref_entry_id, definition, part_of_speech, cefr_level, source_slug, position, created_at
FROM ref_senses
WHERE id = ANY($1::uuid[])
ORDER BY position
`

func (q *Queries) GetRefSensesByIDs(ctx context.Context, ids []uuid.UUID) ([]RefSense, error) {
	rows, err := q.db.Query(ctx, getRefSensesByIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RefSense{}
	for rows.Next() {
		var i RefSense
		if err := rows.Scan(
			&i.ID,
			&i.RefEntryID,
			&i.Definition,
			&i.PartOfSpeech,
			&i.CefrLevel,
			&i.SourceSlug,
			&i.Position,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRefTranslationsByIDs = `-- name: GetRefTranslationsByIDs :many
SELECT id, ref_sense_id, text, source_slug, position
FROM ref_translations
WHERE id = ANY($1::uuid[])
ORDER BY position
`

func (q *Queries) GetRefTranslationsByIDs(ctx context.Context, ids []uuid.UUID) ([]RefTranslation, error) {
	rows, err := q.db.Query(ctx, getRefTranslationsByIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RefTranslation{}
	for rows.Next() {
		var i RefTranslation
		if err := rows.Scan(
			&i.ID,
			&i.RefSenseID,
			&i.Text,
			&i.SourceSlug,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRefTranslationsBySenseIDs = `-- name: GetRefTranslationsBySenseIDs :many

SELECT id, ref_sense_id, text, source_slug, position
FROM ref_translations
WHERE ref_sense_id = ANY($1::uuid[])
ORDER BY position
`

// ---------------------------------------------------------------------------
// ref_translations
// ---------------------------------------------------------------------------
func (q *Queries) GetRefTranslationsBySenseIDs(ctx context.Context, senseIds []uuid.UUID) ([]RefTranslation, error) {
	rows, err := q.db.Query(ctx, getRefTranslationsBySenseIDs, senseIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RefTranslation{}
	for rows.Next() {
		var i RefTranslation
		if err := rows.Scan(
			&i.ID,
			&i.RefSenseID,
			&i.Text,
			&i.SourceSlug,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertRefEntry = `-- name: InsertRefEntry :one
INSERT INTO ref_entries (id, text, text_normalized, created_at)
VALUES ($1, $2, $3, $4)
RETURNING id, text, text_normalized, created_at
`

type InsertRefEntryParams struct {
	ID             uuid.UUID
	Text           string
	TextNormalized string
	CreatedAt      time.Time
}

func (q *Queries) InsertRefEntry(ctx context.Context, arg InsertRefEntryParams) (RefEntry, error) {
	row := q.db.QueryRow(ctx, insertRefEntry,
		arg.ID,
		arg.Text,
		arg.TextNormalized,
		arg.CreatedAt,
	)
	var i RefEntry
	err := row.Scan(
		&i.ID,
		&i.Text,
		&i.TextNormalized,
		&i.CreatedAt,
	)
	return i, err
}

const insertRefExample = `-- name: InsertRefExample :one
INSERT INTO ref_examples (id, ref_sense_id, sentence, translation, source_slug, position)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, ref_sense_id, sentence, translation, source_slug, position
`

type InsertRefExampleParams struct {
	ID          uuid.UUID
	RefSenseID  uuid.UUID
	Sentence    string
	Translation pgtype.Text
	SourceSlug  string
	Position    int32
}

func (q *Queries) InsertRefExample(ctx context.Context, arg InsertRefExampleParams) (RefExample, error) {
	row := q.db.QueryRow(ctx, insertRefExample,
		arg.ID,
		arg.RefSenseID,
		arg.Sentence,
		arg.Translation,
		arg.SourceSlug,
		arg.Position,
	)
	var i RefExample
	err := row.Scan(
		&i.ID,
		&i.RefSenseID,
		&i.Sentence,
		&i.Translation,
		&i.SourceSlug,
		&i.Position,
	)
	return i, err
}

const insertRefImage = `-- name: InsertRefImage :one
INSERT INTO ref_images (id, ref_entry_id, url, caption, source_slug)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, ref_entry_id, url, caption, source_slug
`

type InsertRefImageParams struct {
	ID         uuid.UUID
	RefEntryID uuid.UUID
	Url        string
	Caption    pgtype.Text
	SourceSlug string
}

func (q *Queries) InsertRefImage(ctx context.Context, arg InsertRefImageParams) (RefImage, error) {
	row := q.db.QueryRow(ctx, insertRefImage,
		arg.ID,
		arg.RefEntryID,
		arg.Url,
		arg.Caption,
		arg.SourceSlug,
	)
	var i RefImage
	err := row.Scan(
		&i.ID,
		&i.RefEntryID,
		&i.Url,
		&i.Caption,
		&i.SourceSlug,
	)
	return i, err
}

const insertRefPronunciation = `-- name: InsertRefPronunciation :one
INSERT INTO ref_pronunciations (id, ref_entry_id, transcription, audio_url, region, source_slug)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, ref_entry_id, transcription, audio_url, region, source_slug
`

type InsertRefPronunciationParams struct {
	ID            uuid.UUID
	RefEntryID    uuid.UUID
	Transcription string
	AudioUrl      pgtype.Text
	Region        pgtype.Text
	SourceSlug    string
}

func (q *Queries) InsertRefPronunciation(ctx context.Context, arg InsertRefPronunciationParams) (RefPronunciation, error) {
	row := q.db.QueryRow(ctx, insertRefPronunciation,
		arg.ID,
		arg.RefEntryID,
		arg.Transcription,
		arg.AudioUrl,
		arg.Region,
		arg.SourceSlug,
	)
	var i RefPronunciation
	err := row.Scan(
		&i.ID,
		&i.RefEntryID,
		&i.Transcription,
		&i.AudioUrl,
		&i.Region,
		&i.SourceSlug,
	)
	return i, err
}

const insertRefSense = `-- name: InsertRefSense :one
INSERT INTO ref_senses (id, ref_entry_id, definition, part_of_speech, cefr_level, source_slug, position, created_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, ref_entry_id, definition, part_of_speech, cefr_level, source_slug, position, created_at
`

type InsertRefSenseParams struct {
	ID           uuid.UUID
	RefEntryID   uuid.UUID
	Definition   pgtype.Text
	PartOfSpeech NullPartOfSpeech
	CefrLevel    pgtype.Text
	SourceSlug   string
	Position     int32
	CreatedAt    time.Time
}

func (q *Queries) InsertRefSense(ctx context.Context, arg InsertRefSenseParams) (RefSense, error) {
	row := q.db.QueryRow(ctx, insertRefSense,
		arg.ID,
		arg.RefEntryID,
		arg.Definition,
		arg.PartOfSpeech,
		arg.CefrLevel,
		arg.SourceSlug,
		arg.Position,
		arg.CreatedAt,
	)
	var i RefSense
	err := row.Scan(
		&i.ID,
		&i.RefEntryID,
		&i.Definition,
		&i.PartOfSpeech,
		&i.CefrLevel,
		&i.SourceSlug,
		&i.Position,
		&i.CreatedAt,
	)
	return i, err
}

const insertRefTranslation = `-- name: InsertRefTranslation :one
INSERT INTO ref_translations (id, ref_sense_id, text, source_slug, position)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, ref_sense_id, text, source_slug, position
`

type InsertRefTranslationParams struct {
	ID         uuid.UUID
	RefSenseID uuid.UUID
	Text       string
	SourceSlug string
	Position   int32
}

func (q *Queries) InsertRefTranslation(ctx context.Context, arg InsertRefTranslationParams) (RefTranslation, error) {
	row := q.db.QueryRow(ctx, insertRefTranslation,
		arg.ID,
		arg.RefSenseID,
		arg.Text,
		arg.SourceSlug,
		arg.Position,
	)
	var i RefTranslation
	err := row.Scan(
		&i.ID,
		&i.RefSenseID,
		&i.Text,
		&i.SourceSlug,
		&i.Position,
	)
	return i, err
}

const searchRefEntries = `-- name: SearchRefEntries :many
SELECT id, text, text_normalized, created_at
FROM ref_entries
WHERE text_normalized % $1::text
ORDER BY similarity(text_normalized, $1::text) DESC
LIMIT $2::int
`

type SearchRefEntriesParams struct {
	Query string
	Lim   int32
}

func (q *Queries) SearchRefEntries(ctx context.Context, arg SearchRefEntriesParams) ([]RefEntry, error) {
	rows, err := q.db.Query(ctx, searchRefEntries, arg.Query, arg.Lim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RefEntry{}
	for rows.Next() {
		var i RefEntry
		if err := rows.Scan(
			&i.ID,
			&i.Text,
			&i.TextNormalized,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertRefEntry = `-- name: UpsertRefEntry :exec
INSERT INTO ref_entries (id, text, text_normalized)
VALUES ($1, $2, $3)
ON CONFLICT (text_normalized) DO NOTHING
`

type UpsertRefEntryParams struct {
	ID             uuid.UUID
	Text           string
	TextNormalized string
}

func (q *Queries) UpsertRefEntry(ctx context.Context, arg UpsertRefEntryParams) error {
	_, err := q.db.Exec(ctx, upsertRefEntry, arg.ID, arg.Text, arg.TextNormalized)
	return err
}
