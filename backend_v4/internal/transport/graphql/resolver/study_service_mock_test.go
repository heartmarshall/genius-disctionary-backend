// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package resolver

import (
	"context"
	"github.com/heartmarshall/myenglish-backend/internal/domain"
	"github.com/heartmarshall/myenglish-backend/internal/service/study"
	"sync"
)

// Ensure, that studyServiceMock does implement studyService.
// If this is not the case, regenerate this file with moq.
var _ studyService = &studyServiceMock{}

// studyServiceMock is a mock implementation of studyService.
//
//	func TestSomethingThatUsesstudyService(t *testing.T) {
//
//		// make and configure a mocked studyService
//		mockedstudyService := &studyServiceMock{
//			AbandonSessionFunc: func(ctx context.Context) error {
//				panic("mock out the AbandonSession method")
//			},
//			BatchCreateCardsFunc: func(ctx context.Context, input study.BatchCreateCardsInput) (study.BatchCreateResult, error) {
//				panic("mock out the BatchCreateCards method")
//			},
//			CreateCardFunc: func(ctx context.Context, input study.CreateCardInput) (*domain.Card, error) {
//				panic("mock out the CreateCard method")
//			},
//			DeleteCardFunc: func(ctx context.Context, input study.DeleteCardInput) error {
//				panic("mock out the DeleteCard method")
//			},
//			FinishSessionFunc: func(ctx context.Context, input study.FinishSessionInput) (*domain.StudySession, error) {
//				panic("mock out the FinishSession method")
//			},
//			GetCardHistoryFunc: func(ctx context.Context, input study.GetCardHistoryInput) ([]*domain.ReviewLog, int, error) {
//				panic("mock out the GetCardHistory method")
//			},
//			GetCardStatsFunc: func(ctx context.Context, input study.GetCardHistoryInput) (domain.CardStats, error) {
//				panic("mock out the GetCardStats method")
//			},
//			GetDashboardFunc: func(ctx context.Context) (domain.Dashboard, error) {
//				panic("mock out the GetDashboard method")
//			},
//			GetStudyQueueFunc: func(ctx context.Context, input study.GetQueueInput) ([]*domain.Card, error) {
//				panic("mock out the GetStudyQueue method")
//			},
//			GetStudyQueueEntriesFunc: func(ctx context.Context, input study.GetQueueInput) ([]*domain.Entry, error) {
//				panic("mock out the GetStudyQueueEntries method")
//			},
//			ReviewCardFunc: func(ctx context.Context, input study.ReviewCardInput) (*domain.Card, error) {
//				panic("mock out the ReviewCard method")
//			},
//			StartSessionFunc: func(ctx context.Context) (*domain.StudySession, error) {
//				panic("mock out the StartSession method")
//			},
//			UndoReviewFunc: func(ctx context.Context, input study.UndoReviewInput) (*domain.Card, error) {
//				panic("mock out the UndoReview method")
//			},
//		}
//
//		// use mockedstudyService in code that requires studyService
//		// and then make assertions.
//
//	}
type studyServiceMock struct {
	// AbandonSessionFunc mocks the AbandonSession method.
	AbandonSessionFunc func(ctx context.Context) error

	// BatchCreateCardsFunc mocks the BatchCreateCards method.
	BatchCreateCardsFunc func(ctx context.Context, input study.BatchCreateCardsInput) (study.BatchCreateResult, error)

	// CreateCardFunc mocks the CreateCard method.
	CreateCardFunc func(ctx context.Context, input study.CreateCardInput) (*domain.Card, error)

	// DeleteCardFunc mocks the DeleteCard method.
	DeleteCardFunc func(ctx context.Context, input study.DeleteCardInput) error

	// FinishActiveSessionFunc mocks the FinishActiveSession method.
	FinishActiveSessionFunc func(ctx context.Context) (*domain.StudySession, error)

	// FinishSessionFunc mocks the FinishSession method.
	FinishSessionFunc func(ctx context.Context, input study.FinishSessionInput) (*domain.StudySession, error)

	// GetCardHistoryFunc mocks the GetCardHistory method.
	GetCardHistoryFunc func(ctx context.Context, input study.GetCardHistoryInput) ([]*domain.ReviewLog, int, error)

	// GetCardStatsFunc mocks the GetCardStats method.
	GetCardStatsFunc func(ctx context.Context, input study.GetCardHistoryInput) (domain.CardStats, error)

	// GetActiveSessionFunc mocks the GetActiveSession method.
	GetActiveSessionFunc func(ctx context.Context) (*domain.StudySession, error)

	// GetDashboardFunc mocks the GetDashboard method.
	GetDashboardFunc func(ctx context.Context) (domain.Dashboard, error)

	// GetStudyQueueFunc mocks the GetStudyQueue method.
	GetStudyQueueFunc func(ctx context.Context, input study.GetQueueInput) ([]*domain.Card, error)

	// GetStudyQueueEntriesFunc mocks the GetStudyQueueEntries method.
	GetStudyQueueEntriesFunc func(ctx context.Context, input study.GetQueueInput) ([]*domain.Entry, error)

	// ReviewCardFunc mocks the ReviewCard method.
	ReviewCardFunc func(ctx context.Context, input study.ReviewCardInput) (*domain.Card, error)

	// StartSessionFunc mocks the StartSession method.
	StartSessionFunc func(ctx context.Context) (*domain.StudySession, error)

	// UndoReviewFunc mocks the UndoReview method.
	UndoReviewFunc func(ctx context.Context, input study.UndoReviewInput) (*domain.Card, error)

	// calls tracks calls to the methods.
	calls struct {
		// AbandonSession holds details about calls to the AbandonSession method.
		AbandonSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// BatchCreateCards holds details about calls to the BatchCreateCards method.
		BatchCreateCards []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input study.BatchCreateCardsInput
		}
		// CreateCard holds details about calls to the CreateCard method.
		CreateCard []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input study.CreateCardInput
		}
		// DeleteCard holds details about calls to the DeleteCard method.
		DeleteCard []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input study.DeleteCardInput
		}
		// FinishActiveSession holds details about calls to the FinishActiveSession method.
		FinishActiveSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FinishSession holds details about calls to the FinishSession method.
		FinishSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input study.FinishSessionInput
		}
		// GetCardHistory holds details about calls to the GetCardHistory method.
		GetCardHistory []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input study.GetCardHistoryInput
		}
		// GetCardStats holds details about calls to the GetCardStats method.
		GetCardStats []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input study.GetCardHistoryInput
		}
		// GetActiveSession holds details about calls to the GetActiveSession method.
		GetActiveSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetDashboard holds details about calls to the GetDashboard method.
		GetDashboard []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetStudyQueue holds details about calls to the GetStudyQueue method.
		GetStudyQueue []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input study.GetQueueInput
		}
		// GetStudyQueueEntries holds details about calls to the GetStudyQueueEntries method.
		GetStudyQueueEntries []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input study.GetQueueInput
		}
		// ReviewCard holds details about calls to the ReviewCard method.
		ReviewCard []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input study.ReviewCardInput
		}
		// StartSession holds details about calls to the StartSession method.
		StartSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// UndoReview holds details about calls to the UndoReview method.
		UndoReview []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input study.UndoReviewInput
		}
	}
	lockAbandonSession   sync.RWMutex
	lockBatchCreateCards sync.RWMutex
	lockCreateCard       sync.RWMutex
	lockDeleteCard       sync.RWMutex
	lockFinishActiveSession sync.RWMutex
	lockFinishSession      sync.RWMutex
	lockGetCardHistory   sync.RWMutex
	lockGetCardStats     sync.RWMutex
	lockGetActiveSession sync.RWMutex
	lockGetDashboard     sync.RWMutex
	lockGetStudyQueue        sync.RWMutex
	lockGetStudyQueueEntries sync.RWMutex
	lockReviewCard           sync.RWMutex
	lockStartSession     sync.RWMutex
	lockUndoReview       sync.RWMutex
}

// AbandonSession calls AbandonSessionFunc.
func (mock *studyServiceMock) AbandonSession(ctx context.Context) error {
	if mock.AbandonSessionFunc == nil {
		panic("studyServiceMock.AbandonSessionFunc: method is nil but studyService.AbandonSession was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockAbandonSession.Lock()
	mock.calls.AbandonSession = append(mock.calls.AbandonSession, callInfo)
	mock.lockAbandonSession.Unlock()
	return mock.AbandonSessionFunc(ctx)
}

// AbandonSessionCalls gets all the calls that were made to AbandonSession.
// Check the length with:
//
//	len(mockedstudyService.AbandonSessionCalls())
func (mock *studyServiceMock) AbandonSessionCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockAbandonSession.RLock()
	calls = mock.calls.AbandonSession
	mock.lockAbandonSession.RUnlock()
	return calls
}

// BatchCreateCards calls BatchCreateCardsFunc.
func (mock *studyServiceMock) BatchCreateCards(ctx context.Context, input study.BatchCreateCardsInput) (study.BatchCreateResult, error) {
	if mock.BatchCreateCardsFunc == nil {
		panic("studyServiceMock.BatchCreateCardsFunc: method is nil but studyService.BatchCreateCards was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Input study.BatchCreateCardsInput
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockBatchCreateCards.Lock()
	mock.calls.BatchCreateCards = append(mock.calls.BatchCreateCards, callInfo)
	mock.lockBatchCreateCards.Unlock()
	return mock.BatchCreateCardsFunc(ctx, input)
}

// BatchCreateCardsCalls gets all the calls that were made to BatchCreateCards.
// Check the length with:
//
//	len(mockedstudyService.BatchCreateCardsCalls())
func (mock *studyServiceMock) BatchCreateCardsCalls() []struct {
	Ctx   context.Context
	Input study.BatchCreateCardsInput
} {
	var calls []struct {
		Ctx   context.Context
		Input study.BatchCreateCardsInput
	}
	mock.lockBatchCreateCards.RLock()
	calls = mock.calls.BatchCreateCards
	mock.lockBatchCreateCards.RUnlock()
	return calls
}

// CreateCard calls CreateCardFunc.
func (mock *studyServiceMock) CreateCard(ctx context.Context, input study.CreateCardInput) (*domain.Card, error) {
	if mock.CreateCardFunc == nil {
		panic("studyServiceMock.CreateCardFunc: method is nil but studyService.CreateCard was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Input study.CreateCardInput
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockCreateCard.Lock()
	mock.calls.CreateCard = append(mock.calls.CreateCard, callInfo)
	mock.lockCreateCard.Unlock()
	return mock.CreateCardFunc(ctx, input)
}

// CreateCardCalls gets all the calls that were made to CreateCard.
// Check the length with:
//
//	len(mockedstudyService.CreateCardCalls())
func (mock *studyServiceMock) CreateCardCalls() []struct {
	Ctx   context.Context
	Input study.CreateCardInput
} {
	var calls []struct {
		Ctx   context.Context
		Input study.CreateCardInput
	}
	mock.lockCreateCard.RLock()
	calls = mock.calls.CreateCard
	mock.lockCreateCard.RUnlock()
	return calls
}

// DeleteCard calls DeleteCardFunc.
func (mock *studyServiceMock) DeleteCard(ctx context.Context, input study.DeleteCardInput) error {
	if mock.DeleteCardFunc == nil {
		panic("studyServiceMock.DeleteCardFunc: method is nil but studyService.DeleteCard was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Input study.DeleteCardInput
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockDeleteCard.Lock()
	mock.calls.DeleteCard = append(mock.calls.DeleteCard, callInfo)
	mock.lockDeleteCard.Unlock()
	return mock.DeleteCardFunc(ctx, input)
}

// DeleteCardCalls gets all the calls that were made to DeleteCard.
// Check the length with:
//
//	len(mockedstudyService.DeleteCardCalls())
func (mock *studyServiceMock) DeleteCardCalls() []struct {
	Ctx   context.Context
	Input study.DeleteCardInput
} {
	var calls []struct {
		Ctx   context.Context
		Input study.DeleteCardInput
	}
	mock.lockDeleteCard.RLock()
	calls = mock.calls.DeleteCard
	mock.lockDeleteCard.RUnlock()
	return calls
}

// FinishActiveSession calls FinishActiveSessionFunc.
func (mock *studyServiceMock) FinishActiveSession(ctx context.Context) (*domain.StudySession, error) {
	if mock.FinishActiveSessionFunc == nil {
		panic("studyServiceMock.FinishActiveSessionFunc: method is nil but studyService.FinishActiveSession was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFinishActiveSession.Lock()
	mock.calls.FinishActiveSession = append(mock.calls.FinishActiveSession, callInfo)
	mock.lockFinishActiveSession.Unlock()
	return mock.FinishActiveSessionFunc(ctx)
}

// FinishActiveSessionCalls gets all the calls that were made to FinishActiveSession.
func (mock *studyServiceMock) FinishActiveSessionCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFinishActiveSession.RLock()
	calls = mock.calls.FinishActiveSession
	mock.lockFinishActiveSession.RUnlock()
	return calls
}

// FinishSession calls FinishSessionFunc.
func (mock *studyServiceMock) FinishSession(ctx context.Context, input study.FinishSessionInput) (*domain.StudySession, error) {
	if mock.FinishSessionFunc == nil {
		panic("studyServiceMock.FinishSessionFunc: method is nil but studyService.FinishSession was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Input study.FinishSessionInput
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockFinishSession.Lock()
	mock.calls.FinishSession = append(mock.calls.FinishSession, callInfo)
	mock.lockFinishSession.Unlock()
	return mock.FinishSessionFunc(ctx, input)
}

// FinishSessionCalls gets all the calls that were made to FinishSession.
// Check the length with:
//
//	len(mockedstudyService.FinishSessionCalls())
func (mock *studyServiceMock) FinishSessionCalls() []struct {
	Ctx   context.Context
	Input study.FinishSessionInput
} {
	var calls []struct {
		Ctx   context.Context
		Input study.FinishSessionInput
	}
	mock.lockFinishSession.RLock()
	calls = mock.calls.FinishSession
	mock.lockFinishSession.RUnlock()
	return calls
}

// GetCardHistory calls GetCardHistoryFunc.
func (mock *studyServiceMock) GetCardHistory(ctx context.Context, input study.GetCardHistoryInput) ([]*domain.ReviewLog, int, error) {
	if mock.GetCardHistoryFunc == nil {
		panic("studyServiceMock.GetCardHistoryFunc: method is nil but studyService.GetCardHistory was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Input study.GetCardHistoryInput
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockGetCardHistory.Lock()
	mock.calls.GetCardHistory = append(mock.calls.GetCardHistory, callInfo)
	mock.lockGetCardHistory.Unlock()
	return mock.GetCardHistoryFunc(ctx, input)
}

// GetCardHistoryCalls gets all the calls that were made to GetCardHistory.
// Check the length with:
//
//	len(mockedstudyService.GetCardHistoryCalls())
func (mock *studyServiceMock) GetCardHistoryCalls() []struct {
	Ctx   context.Context
	Input study.GetCardHistoryInput
} {
	var calls []struct {
		Ctx   context.Context
		Input study.GetCardHistoryInput
	}
	mock.lockGetCardHistory.RLock()
	calls = mock.calls.GetCardHistory
	mock.lockGetCardHistory.RUnlock()
	return calls
}

// GetCardStats calls GetCardStatsFunc.
func (mock *studyServiceMock) GetCardStats(ctx context.Context, input study.GetCardHistoryInput) (domain.CardStats, error) {
	if mock.GetCardStatsFunc == nil {
		panic("studyServiceMock.GetCardStatsFunc: method is nil but studyService.GetCardStats was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Input study.GetCardHistoryInput
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockGetCardStats.Lock()
	mock.calls.GetCardStats = append(mock.calls.GetCardStats, callInfo)
	mock.lockGetCardStats.Unlock()
	return mock.GetCardStatsFunc(ctx, input)
}

// GetCardStatsCalls gets all the calls that were made to GetCardStats.
// Check the length with:
//
//	len(mockedstudyService.GetCardStatsCalls())
func (mock *studyServiceMock) GetCardStatsCalls() []struct {
	Ctx   context.Context
	Input study.GetCardHistoryInput
} {
	var calls []struct {
		Ctx   context.Context
		Input study.GetCardHistoryInput
	}
	mock.lockGetCardStats.RLock()
	calls = mock.calls.GetCardStats
	mock.lockGetCardStats.RUnlock()
	return calls
}

// GetActiveSession calls GetActiveSessionFunc.
func (mock *studyServiceMock) GetActiveSession(ctx context.Context) (*domain.StudySession, error) {
	if mock.GetActiveSessionFunc == nil {
		panic("studyServiceMock.GetActiveSessionFunc: method is nil but studyService.GetActiveSession was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetActiveSession.Lock()
	mock.calls.GetActiveSession = append(mock.calls.GetActiveSession, callInfo)
	mock.lockGetActiveSession.Unlock()
	return mock.GetActiveSessionFunc(ctx)
}

// GetActiveSessionCalls gets all the calls that were made to GetActiveSession.
func (mock *studyServiceMock) GetActiveSessionCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetActiveSession.RLock()
	calls = mock.calls.GetActiveSession
	mock.lockGetActiveSession.RUnlock()
	return calls
}

// GetDashboard calls GetDashboardFunc.
func (mock *studyServiceMock) GetDashboard(ctx context.Context) (domain.Dashboard, error) {
	if mock.GetDashboardFunc == nil {
		panic("studyServiceMock.GetDashboardFunc: method is nil but studyService.GetDashboard was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetDashboard.Lock()
	mock.calls.GetDashboard = append(mock.calls.GetDashboard, callInfo)
	mock.lockGetDashboard.Unlock()
	return mock.GetDashboardFunc(ctx)
}

// GetDashboardCalls gets all the calls that were made to GetDashboard.
// Check the length with:
//
//	len(mockedstudyService.GetDashboardCalls())
func (mock *studyServiceMock) GetDashboardCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetDashboard.RLock()
	calls = mock.calls.GetDashboard
	mock.lockGetDashboard.RUnlock()
	return calls
}

// GetStudyQueue calls GetStudyQueueFunc.
func (mock *studyServiceMock) GetStudyQueue(ctx context.Context, input study.GetQueueInput) ([]*domain.Card, error) {
	if mock.GetStudyQueueFunc == nil {
		panic("studyServiceMock.GetStudyQueueFunc: method is nil but studyService.GetStudyQueue was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Input study.GetQueueInput
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockGetStudyQueue.Lock()
	mock.calls.GetStudyQueue = append(mock.calls.GetStudyQueue, callInfo)
	mock.lockGetStudyQueue.Unlock()
	return mock.GetStudyQueueFunc(ctx, input)
}

// GetStudyQueueCalls gets all the calls that were made to GetStudyQueue.
// Check the length with:
//
//	len(mockedstudyService.GetStudyQueueCalls())
func (mock *studyServiceMock) GetStudyQueueCalls() []struct {
	Ctx   context.Context
	Input study.GetQueueInput
} {
	var calls []struct {
		Ctx   context.Context
		Input study.GetQueueInput
	}
	mock.lockGetStudyQueue.RLock()
	calls = mock.calls.GetStudyQueue
	mock.lockGetStudyQueue.RUnlock()
	return calls
}

// GetStudyQueueEntries calls GetStudyQueueEntriesFunc.
func (mock *studyServiceMock) GetStudyQueueEntries(ctx context.Context, input study.GetQueueInput) ([]*domain.Entry, error) {
	if mock.GetStudyQueueEntriesFunc == nil {
		panic("studyServiceMock.GetStudyQueueEntriesFunc: method is nil but studyService.GetStudyQueueEntries was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Input study.GetQueueInput
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockGetStudyQueueEntries.Lock()
	mock.calls.GetStudyQueueEntries = append(mock.calls.GetStudyQueueEntries, callInfo)
	mock.lockGetStudyQueueEntries.Unlock()
	return mock.GetStudyQueueEntriesFunc(ctx, input)
}

// GetStudyQueueEntriesCalls gets all the calls that were made to GetStudyQueueEntries.
// Check the length with:
//
//	len(mockedstudyService.GetStudyQueueEntriesCalls())
func (mock *studyServiceMock) GetStudyQueueEntriesCalls() []struct {
	Ctx   context.Context
	Input study.GetQueueInput
} {
	var calls []struct {
		Ctx   context.Context
		Input study.GetQueueInput
	}
	mock.lockGetStudyQueueEntries.RLock()
	calls = mock.calls.GetStudyQueueEntries
	mock.lockGetStudyQueueEntries.RUnlock()
	return calls
}

// ReviewCard calls ReviewCardFunc.
func (mock *studyServiceMock) ReviewCard(ctx context.Context, input study.ReviewCardInput) (*domain.Card, error) {
	if mock.ReviewCardFunc == nil {
		panic("studyServiceMock.ReviewCardFunc: method is nil but studyService.ReviewCard was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Input study.ReviewCardInput
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockReviewCard.Lock()
	mock.calls.ReviewCard = append(mock.calls.ReviewCard, callInfo)
	mock.lockReviewCard.Unlock()
	return mock.ReviewCardFunc(ctx, input)
}

// ReviewCardCalls gets all the calls that were made to ReviewCard.
// Check the length with:
//
//	len(mockedstudyService.ReviewCardCalls())
func (mock *studyServiceMock) ReviewCardCalls() []struct {
	Ctx   context.Context
	Input study.ReviewCardInput
} {
	var calls []struct {
		Ctx   context.Context
		Input study.ReviewCardInput
	}
	mock.lockReviewCard.RLock()
	calls = mock.calls.ReviewCard
	mock.lockReviewCard.RUnlock()
	return calls
}

// StartSession calls StartSessionFunc.
func (mock *studyServiceMock) StartSession(ctx context.Context) (*domain.StudySession, error) {
	if mock.StartSessionFunc == nil {
		panic("studyServiceMock.StartSessionFunc: method is nil but studyService.StartSession was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockStartSession.Lock()
	mock.calls.StartSession = append(mock.calls.StartSession, callInfo)
	mock.lockStartSession.Unlock()
	return mock.StartSessionFunc(ctx)
}

// StartSessionCalls gets all the calls that were made to StartSession.
// Check the length with:
//
//	len(mockedstudyService.StartSessionCalls())
func (mock *studyServiceMock) StartSessionCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockStartSession.RLock()
	calls = mock.calls.StartSession
	mock.lockStartSession.RUnlock()
	return calls
}

// UndoReview calls UndoReviewFunc.
func (mock *studyServiceMock) UndoReview(ctx context.Context, input study.UndoReviewInput) (*domain.Card, error) {
	if mock.UndoReviewFunc == nil {
		panic("studyServiceMock.UndoReviewFunc: method is nil but studyService.UndoReview was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Input study.UndoReviewInput
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockUndoReview.Lock()
	mock.calls.UndoReview = append(mock.calls.UndoReview, callInfo)
	mock.lockUndoReview.Unlock()
	return mock.UndoReviewFunc(ctx, input)
}

// UndoReviewCalls gets all the calls that were made to UndoReview.
// Check the length with:
//
//	len(mockedstudyService.UndoReviewCalls())
func (mock *studyServiceMock) UndoReviewCalls() []struct {
	Ctx   context.Context
	Input study.UndoReviewInput
} {
	var calls []struct {
		Ctx   context.Context
		Input study.UndoReviewInput
	}
	mock.lockUndoReview.RLock()
	calls = mock.calls.UndoReview
	mock.lockUndoReview.RUnlock()
	return calls
}
