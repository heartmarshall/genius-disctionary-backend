// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package resolver

import (
	"context"
	"github.com/google/uuid"
	"github.com/heartmarshall/myenglish-backend/internal/domain"
	"github.com/heartmarshall/myenglish-backend/internal/service/dictionary"
	"sync"
)

// Ensure, that dictionaryServiceMock does implement dictionaryService.
// If this is not the case, regenerate this file with moq.
var _ dictionaryService = &dictionaryServiceMock{}

// dictionaryServiceMock is a mock implementation of dictionaryService.
//
//	func TestSomethingThatUsesdictionaryService(t *testing.T) {
//
//		// make and configure a mocked dictionaryService
//		mockeddictionaryService := &dictionaryServiceMock{
//			BatchDeleteEntriesFunc: func(ctx context.Context, entryIDs []uuid.UUID) (*dictionary.BatchResult, error) {
//				panic("mock out the BatchDeleteEntries method")
//			},
//			CreateEntryCustomFunc: func(ctx context.Context, input dictionary.CreateCustomInput) (*domain.Entry, error) {
//				panic("mock out the CreateEntryCustom method")
//			},
//			CreateEntryFromCatalogFunc: func(ctx context.Context, input dictionary.CreateFromCatalogInput) (*domain.Entry, error) {
//				panic("mock out the CreateEntryFromCatalog method")
//			},
//			DeleteEntryFunc: func(ctx context.Context, entryID uuid.UUID) error {
//				panic("mock out the DeleteEntry method")
//			},
//			ExportEntriesFunc: func(ctx context.Context) (*dictionary.ExportResult, error) {
//				panic("mock out the ExportEntries method")
//			},
//			FindDeletedEntriesFunc: func(ctx context.Context, limit int, offset int) ([]domain.Entry, int, error) {
//				panic("mock out the FindDeletedEntries method")
//			},
//			FindEntriesFunc: func(ctx context.Context, input dictionary.FindInput) (*dictionary.FindResult, error) {
//				panic("mock out the FindEntries method")
//			},
//			GetEntryFunc: func(ctx context.Context, entryID uuid.UUID) (*domain.Entry, error) {
//				panic("mock out the GetEntry method")
//			},
//			ImportEntriesFunc: func(ctx context.Context, input dictionary.ImportInput) (*dictionary.ImportResult, error) {
//				panic("mock out the ImportEntries method")
//			},
//			PreviewRefEntryFunc: func(ctx context.Context, text string) (*domain.RefEntry, error) {
//				panic("mock out the PreviewRefEntry method")
//			},
//			RestoreEntryFunc: func(ctx context.Context, entryID uuid.UUID) (*domain.Entry, error) {
//				panic("mock out the RestoreEntry method")
//			},
//			SearchCatalogFunc: func(ctx context.Context, query string, limit int) ([]domain.RefEntry, error) {
//				panic("mock out the SearchCatalog method")
//			},
//			UpdateNotesFunc: func(ctx context.Context, input dictionary.UpdateNotesInput) (*domain.Entry, error) {
//				panic("mock out the UpdateNotes method")
//			},
//		}
//
//		// use mockeddictionaryService in code that requires dictionaryService
//		// and then make assertions.
//
//	}
type dictionaryServiceMock struct {
	// BatchDeleteEntriesFunc mocks the BatchDeleteEntries method.
	BatchDeleteEntriesFunc func(ctx context.Context, entryIDs []uuid.UUID) (*dictionary.BatchResult, error)

	// CreateEntryCustomFunc mocks the CreateEntryCustom method.
	CreateEntryCustomFunc func(ctx context.Context, input dictionary.CreateCustomInput) (*domain.Entry, error)

	// CreateEntryFromCatalogFunc mocks the CreateEntryFromCatalog method.
	CreateEntryFromCatalogFunc func(ctx context.Context, input dictionary.CreateFromCatalogInput) (*domain.Entry, error)

	// DeleteEntryFunc mocks the DeleteEntry method.
	DeleteEntryFunc func(ctx context.Context, entryID uuid.UUID) error

	// ExportEntriesFunc mocks the ExportEntries method.
	ExportEntriesFunc func(ctx context.Context) (*dictionary.ExportResult, error)

	// FindDeletedEntriesFunc mocks the FindDeletedEntries method.
	FindDeletedEntriesFunc func(ctx context.Context, limit int, offset int) ([]domain.Entry, int, error)

	// FindEntriesFunc mocks the FindEntries method.
	FindEntriesFunc func(ctx context.Context, input dictionary.FindInput) (*dictionary.FindResult, error)

	// GetEntryFunc mocks the GetEntry method.
	GetEntryFunc func(ctx context.Context, entryID uuid.UUID) (*domain.Entry, error)

	// ImportEntriesFunc mocks the ImportEntries method.
	ImportEntriesFunc func(ctx context.Context, input dictionary.ImportInput) (*dictionary.ImportResult, error)

	// PreviewRefEntryFunc mocks the PreviewRefEntry method.
	PreviewRefEntryFunc func(ctx context.Context, text string) (*domain.RefEntry, error)

	// RestoreEntryFunc mocks the RestoreEntry method.
	RestoreEntryFunc func(ctx context.Context, entryID uuid.UUID) (*domain.Entry, error)

	// SearchCatalogFunc mocks the SearchCatalog method.
	SearchCatalogFunc func(ctx context.Context, query string, limit int) ([]domain.RefEntry, error)

	// UpdateNotesFunc mocks the UpdateNotes method.
	UpdateNotesFunc func(ctx context.Context, input dictionary.UpdateNotesInput) (*domain.Entry, error)

	// calls tracks calls to the methods.
	calls struct {
		// BatchDeleteEntries holds details about calls to the BatchDeleteEntries method.
		BatchDeleteEntries []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// EntryIDs is the entryIDs argument value.
			EntryIDs []uuid.UUID
		}
		// CreateEntryCustom holds details about calls to the CreateEntryCustom method.
		CreateEntryCustom []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input dictionary.CreateCustomInput
		}
		// CreateEntryFromCatalog holds details about calls to the CreateEntryFromCatalog method.
		CreateEntryFromCatalog []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input dictionary.CreateFromCatalogInput
		}
		// DeleteEntry holds details about calls to the DeleteEntry method.
		DeleteEntry []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// EntryID is the entryID argument value.
			EntryID uuid.UUID
		}
		// ExportEntries holds details about calls to the ExportEntries method.
		ExportEntries []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FindDeletedEntries holds details about calls to the FindDeletedEntries method.
		FindDeletedEntries []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Limit is the limit argument value.
			Limit int
			// Offset is the offset argument value.
			Offset int
		}
		// FindEntries holds details about calls to the FindEntries method.
		FindEntries []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input dictionary.FindInput
		}
		// GetEntry holds details about calls to the GetEntry method.
		GetEntry []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// EntryID is the entryID argument value.
			EntryID uuid.UUID
		}
		// ImportEntries holds details about calls to the ImportEntries method.
		ImportEntries []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input dictionary.ImportInput
		}
		// PreviewRefEntry holds details about calls to the PreviewRefEntry method.
		PreviewRefEntry []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Text is the text argument value.
			Text string
		}
		// RestoreEntry holds details about calls to the RestoreEntry method.
		RestoreEntry []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// EntryID is the entryID argument value.
			EntryID uuid.UUID
		}
		// SearchCatalog holds details about calls to the SearchCatalog method.
		SearchCatalog []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Query is the query argument value.
			Query string
			// Limit is the limit argument value.
			Limit int
		}
		// UpdateNotes holds details about calls to the UpdateNotes method.
		UpdateNotes []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input dictionary.UpdateNotesInput
		}
	}
	lockBatchDeleteEntries     sync.RWMutex
	lockCreateEntryCustom      sync.RWMutex
	lockCreateEntryFromCatalog sync.RWMutex
	lockDeleteEntry            sync.RWMutex
	lockExportEntries          sync.RWMutex
	lockFindDeletedEntries     sync.RWMutex
	lockFindEntries            sync.RWMutex
	lockGetEntry               sync.RWMutex
	lockImportEntries          sync.RWMutex
	lockPreviewRefEntry        sync.RWMutex
	lockRestoreEntry           sync.RWMutex
	lockSearchCatalog          sync.RWMutex
	lockUpdateNotes            sync.RWMutex
}

// BatchDeleteEntries calls BatchDeleteEntriesFunc.
func (mock *dictionaryServiceMock) BatchDeleteEntries(ctx context.Context, entryIDs []uuid.UUID) (*dictionary.BatchResult, error) {
	if mock.BatchDeleteEntriesFunc == nil {
		panic("dictionaryServiceMock.BatchDeleteEntriesFunc: method is nil but dictionaryService.BatchDeleteEntries was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		EntryIDs []uuid.UUID
	}{
		Ctx:      ctx,
		EntryIDs: entryIDs,
	}
	mock.lockBatchDeleteEntries.Lock()
	mock.calls.BatchDeleteEntries = append(mock.calls.BatchDeleteEntries, callInfo)
	mock.lockBatchDeleteEntries.Unlock()
	return mock.BatchDeleteEntriesFunc(ctx, entryIDs)
}

// BatchDeleteEntriesCalls gets all the calls that were made to BatchDeleteEntries.
// Check the length with:
//
//	len(mockeddictionaryService.BatchDeleteEntriesCalls())
func (mock *dictionaryServiceMock) BatchDeleteEntriesCalls() []struct {
	Ctx      context.Context
	EntryIDs []uuid.UUID
} {
	var calls []struct {
		Ctx      context.Context
		EntryIDs []uuid.UUID
	}
	mock.lockBatchDeleteEntries.RLock()
	calls = mock.calls.BatchDeleteEntries
	mock.lockBatchDeleteEntries.RUnlock()
	return calls
}

// CreateEntryCustom calls CreateEntryCustomFunc.
func (mock *dictionaryServiceMock) CreateEntryCustom(ctx context.Context, input dictionary.CreateCustomInput) (*domain.Entry, error) {
	if mock.CreateEntryCustomFunc == nil {
		panic("dictionaryServiceMock.CreateEntryCustomFunc: method is nil but dictionaryService.CreateEntryCustom was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Input dictionary.CreateCustomInput
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockCreateEntryCustom.Lock()
	mock.calls.CreateEntryCustom = append(mock.calls.CreateEntryCustom, callInfo)
	mock.lockCreateEntryCustom.Unlock()
	return mock.CreateEntryCustomFunc(ctx, input)
}

// CreateEntryCustomCalls gets all the calls that were made to CreateEntryCustom.
// Check the length with:
//
//	len(mockeddictionaryService.CreateEntryCustomCalls())
func (mock *dictionaryServiceMock) CreateEntryCustomCalls() []struct {
	Ctx   context.Context
	Input dictionary.CreateCustomInput
} {
	var calls []struct {
		Ctx   context.Context
		Input dictionary.CreateCustomInput
	}
	mock.lockCreateEntryCustom.RLock()
	calls = mock.calls.CreateEntryCustom
	mock.lockCreateEntryCustom.RUnlock()
	return calls
}

// CreateEntryFromCatalog calls CreateEntryFromCatalogFunc.
func (mock *dictionaryServiceMock) CreateEntryFromCatalog(ctx context.Context, input dictionary.CreateFromCatalogInput) (*domain.Entry, error) {
	if mock.CreateEntryFromCatalogFunc == nil {
		panic("dictionaryServiceMock.CreateEntryFromCatalogFunc: method is nil but dictionaryService.CreateEntryFromCatalog was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Input dictionary.CreateFromCatalogInput
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockCreateEntryFromCatalog.Lock()
	mock.calls.CreateEntryFromCatalog = append(mock.calls.CreateEntryFromCatalog, callInfo)
	mock.lockCreateEntryFromCatalog.Unlock()
	return mock.CreateEntryFromCatalogFunc(ctx, input)
}

// CreateEntryFromCatalogCalls gets all the calls that were made to CreateEntryFromCatalog.
// Check the length with:
//
//	len(mockeddictionaryService.CreateEntryFromCatalogCalls())
func (mock *dictionaryServiceMock) CreateEntryFromCatalogCalls() []struct {
	Ctx   context.Context
	Input dictionary.CreateFromCatalogInput
} {
	var calls []struct {
		Ctx   context.Context
		Input dictionary.CreateFromCatalogInput
	}
	mock.lockCreateEntryFromCatalog.RLock()
	calls = mock.calls.CreateEntryFromCatalog
	mock.lockCreateEntryFromCatalog.RUnlock()
	return calls
}

// DeleteEntry calls DeleteEntryFunc.
func (mock *dictionaryServiceMock) DeleteEntry(ctx context.Context, entryID uuid.UUID) error {
	if mock.DeleteEntryFunc == nil {
		panic("dictionaryServiceMock.DeleteEntryFunc: method is nil but dictionaryService.DeleteEntry was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		EntryID uuid.UUID
	}{
		Ctx:     ctx,
		EntryID: entryID,
	}
	mock.lockDeleteEntry.Lock()
	mock.calls.DeleteEntry = append(mock.calls.DeleteEntry, callInfo)
	mock.lockDeleteEntry.Unlock()
	return mock.DeleteEntryFunc(ctx, entryID)
}

// DeleteEntryCalls gets all the calls that were made to DeleteEntry.
// Check the length with:
//
//	len(mockeddictionaryService.DeleteEntryCalls())
func (mock *dictionaryServiceMock) DeleteEntryCalls() []struct {
	Ctx     context.Context
	EntryID uuid.UUID
} {
	var calls []struct {
		Ctx     context.Context
		EntryID uuid.UUID
	}
	mock.lockDeleteEntry.RLock()
	calls = mock.calls.DeleteEntry
	mock.lockDeleteEntry.RUnlock()
	return calls
}

// ExportEntries calls ExportEntriesFunc.
func (mock *dictionaryServiceMock) ExportEntries(ctx context.Context) (*dictionary.ExportResult, error) {
	if mock.ExportEntriesFunc == nil {
		panic("dictionaryServiceMock.ExportEntriesFunc: method is nil but dictionaryService.ExportEntries was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockExportEntries.Lock()
	mock.calls.ExportEntries = append(mock.calls.ExportEntries, callInfo)
	mock.lockExportEntries.Unlock()
	return mock.ExportEntriesFunc(ctx)
}

// ExportEntriesCalls gets all the calls that were made to ExportEntries.
// Check the length with:
//
//	len(mockeddictionaryService.ExportEntriesCalls())
func (mock *dictionaryServiceMock) ExportEntriesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockExportEntries.RLock()
	calls = mock.calls.ExportEntries
	mock.lockExportEntries.RUnlock()
	return calls
}

// FindDeletedEntries calls FindDeletedEntriesFunc.
func (mock *dictionaryServiceMock) FindDeletedEntries(ctx context.Context, limit int, offset int) ([]domain.Entry, int, error) {
	if mock.FindDeletedEntriesFunc == nil {
		panic("dictionaryServiceMock.FindDeletedEntriesFunc: method is nil but dictionaryService.FindDeletedEntries was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Limit  int
		Offset int
	}{
		Ctx:    ctx,
		Limit:  limit,
		Offset: offset,
	}
	mock.lockFindDeletedEntries.Lock()
	mock.calls.FindDeletedEntries = append(mock.calls.FindDeletedEntries, callInfo)
	mock.lockFindDeletedEntries.Unlock()
	return mock.FindDeletedEntriesFunc(ctx, limit, offset)
}

// FindDeletedEntriesCalls gets all the calls that were made to FindDeletedEntries.
// Check the length with:
//
//	len(mockeddictionaryService.FindDeletedEntriesCalls())
func (mock *dictionaryServiceMock) FindDeletedEntriesCalls() []struct {
	Ctx    context.Context
	Limit  int
	Offset int
} {
	var calls []struct {
		Ctx    context.Context
		Limit  int
		Offset int
	}
	mock.lockFindDeletedEntries.RLock()
	calls = mock.calls.FindDeletedEntries
	mock.lockFindDeletedEntries.RUnlock()
	return calls
}

// FindEntries calls FindEntriesFunc.
func (mock *dictionaryServiceMock) FindEntries(ctx context.Context, input dictionary.FindInput) (*dictionary.FindResult, error) {
	if mock.FindEntriesFunc == nil {
		panic("dictionaryServiceMock.FindEntriesFunc: method is nil but dictionaryService.FindEntries was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Input dictionary.FindInput
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockFindEntries.Lock()
	mock.calls.FindEntries = append(mock.calls.FindEntries, callInfo)
	mock.lockFindEntries.Unlock()
	return mock.FindEntriesFunc(ctx, input)
}

// FindEntriesCalls gets all the calls that were made to FindEntries.
// Check the length with:
//
//	len(mockeddictionaryService.FindEntriesCalls())
func (mock *dictionaryServiceMock) FindEntriesCalls() []struct {
	Ctx   context.Context
	Input dictionary.FindInput
} {
	var calls []struct {
		Ctx   context.Context
		Input dictionary.FindInput
	}
	mock.lockFindEntries.RLock()
	calls = mock.calls.FindEntries
	mock.lockFindEntries.RUnlock()
	return calls
}

// GetEntry calls GetEntryFunc.
func (mock *dictionaryServiceMock) GetEntry(ctx context.Context, entryID uuid.UUID) (*domain.Entry, error) {
	if mock.GetEntryFunc == nil {
		panic("dictionaryServiceMock.GetEntryFunc: method is nil but dictionaryService.GetEntry was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		EntryID uuid.UUID
	}{
		Ctx:     ctx,
		EntryID: entryID,
	}
	mock.lockGetEntry.Lock()
	mock.calls.GetEntry = append(mock.calls.GetEntry, callInfo)
	mock.lockGetEntry.Unlock()
	return mock.GetEntryFunc(ctx, entryID)
}

// GetEntryCalls gets all the calls that were made to GetEntry.
// Check the length with:
//
//	len(mockeddictionaryService.GetEntryCalls())
func (mock *dictionaryServiceMock) GetEntryCalls() []struct {
	Ctx     context.Context
	EntryID uuid.UUID
} {
	var calls []struct {
		Ctx     context.Context
		EntryID uuid.UUID
	}
	mock.lockGetEntry.RLock()
	calls = mock.calls.GetEntry
	mock.lockGetEntry.RUnlock()
	return calls
}

// ImportEntries calls ImportEntriesFunc.
func (mock *dictionaryServiceMock) ImportEntries(ctx context.Context, input dictionary.ImportInput) (*dictionary.ImportResult, error) {
	if mock.ImportEntriesFunc == nil {
		panic("dictionaryServiceMock.ImportEntriesFunc: method is nil but dictionaryService.ImportEntries was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Input dictionary.ImportInput
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockImportEntries.Lock()
	mock.calls.ImportEntries = append(mock.calls.ImportEntries, callInfo)
	mock.lockImportEntries.Unlock()
	return mock.ImportEntriesFunc(ctx, input)
}

// ImportEntriesCalls gets all the calls that were made to ImportEntries.
// Check the length with:
//
//	len(mockeddictionaryService.ImportEntriesCalls())
func (mock *dictionaryServiceMock) ImportEntriesCalls() []struct {
	Ctx   context.Context
	Input dictionary.ImportInput
} {
	var calls []struct {
		Ctx   context.Context
		Input dictionary.ImportInput
	}
	mock.lockImportEntries.RLock()
	calls = mock.calls.ImportEntries
	mock.lockImportEntries.RUnlock()
	return calls
}

// PreviewRefEntry calls PreviewRefEntryFunc.
func (mock *dictionaryServiceMock) PreviewRefEntry(ctx context.Context, text string) (*domain.RefEntry, error) {
	if mock.PreviewRefEntryFunc == nil {
		panic("dictionaryServiceMock.PreviewRefEntryFunc: method is nil but dictionaryService.PreviewRefEntry was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Text string
	}{
		Ctx:  ctx,
		Text: text,
	}
	mock.lockPreviewRefEntry.Lock()
	mock.calls.PreviewRefEntry = append(mock.calls.PreviewRefEntry, callInfo)
	mock.lockPreviewRefEntry.Unlock()
	return mock.PreviewRefEntryFunc(ctx, text)
}

// PreviewRefEntryCalls gets all the calls that were made to PreviewRefEntry.
// Check the length with:
//
//	len(mockeddictionaryService.PreviewRefEntryCalls())
func (mock *dictionaryServiceMock) PreviewRefEntryCalls() []struct {
	Ctx  context.Context
	Text string
} {
	var calls []struct {
		Ctx  context.Context
		Text string
	}
	mock.lockPreviewRefEntry.RLock()
	calls = mock.calls.PreviewRefEntry
	mock.lockPreviewRefEntry.RUnlock()
	return calls
}

// RestoreEntry calls RestoreEntryFunc.
func (mock *dictionaryServiceMock) RestoreEntry(ctx context.Context, entryID uuid.UUID) (*domain.Entry, error) {
	if mock.RestoreEntryFunc == nil {
		panic("dictionaryServiceMock.RestoreEntryFunc: method is nil but dictionaryService.RestoreEntry was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		EntryID uuid.UUID
	}{
		Ctx:     ctx,
		EntryID: entryID,
	}
	mock.lockRestoreEntry.Lock()
	mock.calls.RestoreEntry = append(mock.calls.RestoreEntry, callInfo)
	mock.lockRestoreEntry.Unlock()
	return mock.RestoreEntryFunc(ctx, entryID)
}

// RestoreEntryCalls gets all the calls that were made to RestoreEntry.
// Check the length with:
//
//	len(mockeddictionaryService.RestoreEntryCalls())
func (mock *dictionaryServiceMock) RestoreEntryCalls() []struct {
	Ctx     context.Context
	EntryID uuid.UUID
} {
	var calls []struct {
		Ctx     context.Context
		EntryID uuid.UUID
	}
	mock.lockRestoreEntry.RLock()
	calls = mock.calls.RestoreEntry
	mock.lockRestoreEntry.RUnlock()
	return calls
}

// SearchCatalog calls SearchCatalogFunc.
func (mock *dictionaryServiceMock) SearchCatalog(ctx context.Context, query string, limit int) ([]domain.RefEntry, error) {
	if mock.SearchCatalogFunc == nil {
		panic("dictionaryServiceMock.SearchCatalogFunc: method is nil but dictionaryService.SearchCatalog was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Query string
		Limit int
	}{
		Ctx:   ctx,
		Query: query,
		Limit: limit,
	}
	mock.lockSearchCatalog.Lock()
	mock.calls.SearchCatalog = append(mock.calls.SearchCatalog, callInfo)
	mock.lockSearchCatalog.Unlock()
	return mock.SearchCatalogFunc(ctx, query, limit)
}

// SearchCatalogCalls gets all the calls that were made to SearchCatalog.
// Check the length with:
//
//	len(mockeddictionaryService.SearchCatalogCalls())
func (mock *dictionaryServiceMock) SearchCatalogCalls() []struct {
	Ctx   context.Context
	Query string
	Limit int
} {
	var calls []struct {
		Ctx   context.Context
		Query string
		Limit int
	}
	mock.lockSearchCatalog.RLock()
	calls = mock.calls.SearchCatalog
	mock.lockSearchCatalog.RUnlock()
	return calls
}

// UpdateNotes calls UpdateNotesFunc.
func (mock *dictionaryServiceMock) UpdateNotes(ctx context.Context, input dictionary.UpdateNotesInput) (*domain.Entry, error) {
	if mock.UpdateNotesFunc == nil {
		panic("dictionaryServiceMock.UpdateNotesFunc: method is nil but dictionaryService.UpdateNotes was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Input dictionary.UpdateNotesInput
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockUpdateNotes.Lock()
	mock.calls.UpdateNotes = append(mock.calls.UpdateNotes, callInfo)
	mock.lockUpdateNotes.Unlock()
	return mock.UpdateNotesFunc(ctx, input)
}

// UpdateNotesCalls gets all the calls that were made to UpdateNotes.
// Check the length with:
//
//	len(mockeddictionaryService.UpdateNotesCalls())
func (mock *dictionaryServiceMock) UpdateNotesCalls() []struct {
	Ctx   context.Context
	Input dictionary.UpdateNotesInput
} {
	var calls []struct {
		Ctx   context.Context
		Input dictionary.UpdateNotesInput
	}
	mock.lockUpdateNotes.RLock()
	calls = mock.calls.UpdateNotes
	mock.lockUpdateNotes.RUnlock()
	return calls
}
