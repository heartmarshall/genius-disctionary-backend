package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/heartmarshall/myenglish-backend/internal/domain"
	"github.com/heartmarshall/myenglish-backend/internal/service/dictionary"
	"github.com/heartmarshall/myenglish-backend/internal/transport/graphql/dataloader"
	"github.com/heartmarshall/myenglish-backend/internal/transport/graphql/generated"
)

// Senses is the resolver for the senses field.
func (r *dictionaryEntryResolver) Senses(ctx context.Context, obj *domain.Entry) ([]*domain.Sense, error) {
	if len(obj.Senses) > 0 {
		return toSensePointers(obj.Senses), nil
	}
	loaders := dataloader.FromContext(ctx)
	if loaders == nil {
		return nil, fmt.Errorf("dataloaders not in context")
	}
	senses, err := loaders.SensesByEntryID.Load(ctx, obj.ID)()
	if err != nil {
		return nil, err
	}
	return toSensePointers(senses), nil
}

// Pronunciations is the resolver for the pronunciations field.
func (r *dictionaryEntryResolver) Pronunciations(ctx context.Context, obj *domain.Entry) ([]*domain.RefPronunciation, error) {
	if len(obj.Pronunciations) > 0 {
		return toPronunciationPointers(obj.Pronunciations), nil
	}
	loaders := dataloader.FromContext(ctx)
	if loaders == nil {
		return nil, fmt.Errorf("dataloaders not in context")
	}
	prons, err := loaders.PronunciationsByEntryID.Load(ctx, obj.ID)()
	if err != nil {
		return nil, err
	}
	return toPronunciationPointers(prons), nil
}

// CatalogImages is the resolver for the catalogImages field.
func (r *dictionaryEntryResolver) CatalogImages(ctx context.Context, obj *domain.Entry) ([]*domain.RefImage, error) {
	if len(obj.CatalogImages) > 0 {
		return toRefImagePointers(obj.CatalogImages), nil
	}
	loaders := dataloader.FromContext(ctx)
	if loaders == nil {
		return nil, fmt.Errorf("dataloaders not in context")
	}
	images, err := loaders.CatalogImagesByEntryID.Load(ctx, obj.ID)()
	if err != nil {
		return nil, err
	}
	return toRefImagePointers(images), nil
}

// UserImages is the resolver for the userImages field.
func (r *dictionaryEntryResolver) UserImages(ctx context.Context, obj *domain.Entry) ([]*domain.UserImage, error) {
	if len(obj.UserImages) > 0 {
		return toUserImagePointers(obj.UserImages), nil
	}
	loaders := dataloader.FromContext(ctx)
	if loaders == nil {
		return nil, fmt.Errorf("dataloaders not in context")
	}
	images, err := loaders.UserImagesByEntryID.Load(ctx, obj.ID)()
	if err != nil {
		return nil, err
	}
	return toUserImagePointers(images), nil
}

// Card is the resolver for the card field.
func (r *dictionaryEntryResolver) Card(ctx context.Context, obj *domain.Entry) (*domain.Card, error) {
	if obj.Card != nil {
		return obj.Card, nil
	}
	loaders := dataloader.FromContext(ctx)
	if loaders == nil {
		return nil, fmt.Errorf("dataloaders not in context")
	}
	return loaders.CardByEntryID.Load(ctx, obj.ID)()
}

// Topics is the resolver for the topics field.
func (r *dictionaryEntryResolver) Topics(ctx context.Context, obj *domain.Entry) ([]*domain.Topic, error) {
	if len(obj.Topics) > 0 {
		return toTopicPointers(obj.Topics), nil
	}
	loaders := dataloader.FromContext(ctx)
	if loaders == nil {
		return nil, fmt.Errorf("dataloaders not in context")
	}
	topics, err := loaders.TopicsByEntryID.Load(ctx, obj.ID)()
	if err != nil {
		return nil, err
	}
	return toTopicPointers(topics), nil
}

// CreateEntryFromCatalog is the resolver for the createEntryFromCatalog field.
func (r *mutationResolver) CreateEntryFromCatalog(ctx context.Context, input generated.CreateEntryFromCatalogInput) (*generated.CreateEntryPayload, error) {
	panic(fmt.Errorf("not implemented: CreateEntryFromCatalog - createEntryFromCatalog"))
}

// CreateEntryCustom is the resolver for the createEntryCustom field.
func (r *mutationResolver) CreateEntryCustom(ctx context.Context, input generated.CreateEntryCustomInput) (*generated.CreateEntryPayload, error) {
	panic(fmt.Errorf("not implemented: CreateEntryCustom - createEntryCustom"))
}

// UpdateEntryNotes is the resolver for the updateEntryNotes field.
func (r *mutationResolver) UpdateEntryNotes(ctx context.Context, input generated.UpdateEntryNotesInput) (*generated.UpdateEntryPayload, error) {
	panic(fmt.Errorf("not implemented: UpdateEntryNotes - updateEntryNotes"))
}

// DeleteEntry is the resolver for the deleteEntry field.
func (r *mutationResolver) DeleteEntry(ctx context.Context, id uuid.UUID) (*generated.DeleteEntryPayload, error) {
	panic(fmt.Errorf("not implemented: DeleteEntry - deleteEntry"))
}

// RestoreEntry is the resolver for the restoreEntry field.
func (r *mutationResolver) RestoreEntry(ctx context.Context, id uuid.UUID) (*generated.RestoreEntryPayload, error) {
	panic(fmt.Errorf("not implemented: RestoreEntry - restoreEntry"))
}

// BatchDeleteEntries is the resolver for the batchDeleteEntries field.
func (r *mutationResolver) BatchDeleteEntries(ctx context.Context, ids []uuid.UUID) (*generated.BatchDeletePayload, error) {
	panic(fmt.Errorf("not implemented: BatchDeleteEntries - batchDeleteEntries"))
}

// ImportEntries is the resolver for the importEntries field.
func (r *mutationResolver) ImportEntries(ctx context.Context, input generated.ImportEntriesInput) (*generated.ImportPayload, error) {
	panic(fmt.Errorf("not implemented: ImportEntries - importEntries"))
}

// SearchCatalog is the resolver for the searchCatalog field.
func (r *queryResolver) SearchCatalog(ctx context.Context, query string, limit *int) ([]*domain.RefEntry, error) {
	panic(fmt.Errorf("not implemented: SearchCatalog - searchCatalog"))
}

// PreviewRefEntry is the resolver for the previewRefEntry field.
func (r *queryResolver) PreviewRefEntry(ctx context.Context, text string) (*domain.RefEntry, error) {
	panic(fmt.Errorf("not implemented: PreviewRefEntry - previewRefEntry"))
}

// Dictionary is the resolver for the dictionary field.
func (r *queryResolver) Dictionary(ctx context.Context, input generated.DictionaryFilterInput) (*generated.DictionaryConnection, error) {
	panic(fmt.Errorf("not implemented: Dictionary - dictionary"))
}

// DictionaryEntry is the resolver for the dictionaryEntry field.
func (r *queryResolver) DictionaryEntry(ctx context.Context, id uuid.UUID) (*domain.Entry, error) {
	panic(fmt.Errorf("not implemented: DictionaryEntry - dictionaryEntry"))
}

// DeletedEntries is the resolver for the deletedEntries field.
func (r *queryResolver) DeletedEntries(ctx context.Context, limit *int, offset *int) (*generated.DeletedEntriesList, error) {
	panic(fmt.Errorf("not implemented: DeletedEntries - deletedEntries"))
}

// ExportEntries is the resolver for the exportEntries field.
func (r *queryResolver) ExportEntries(ctx context.Context) (*dictionary.ExportResult, error) {
	panic(fmt.Errorf("not implemented: ExportEntries - exportEntries"))
}

// Translations is the resolver for the translations field.
func (r *senseResolver) Translations(ctx context.Context, obj *domain.Sense) ([]*domain.Translation, error) {
	if len(obj.Translations) > 0 {
		return toTranslationPointers(obj.Translations), nil
	}
	loaders := dataloader.FromContext(ctx)
	if loaders == nil {
		return nil, fmt.Errorf("dataloaders not in context")
	}
	translations, err := loaders.TranslationsBySenseID.Load(ctx, obj.ID)()
	if err != nil {
		return nil, err
	}
	return toTranslationPointers(translations), nil
}

// Examples is the resolver for the examples field.
func (r *senseResolver) Examples(ctx context.Context, obj *domain.Sense) ([]*domain.Example, error) {
	if len(obj.Examples) > 0 {
		return toExamplePointers(obj.Examples), nil
	}
	loaders := dataloader.FromContext(ctx)
	if loaders == nil {
		return nil, fmt.Errorf("dataloaders not in context")
	}
	examples, err := loaders.ExamplesBySenseID.Load(ctx, obj.ID)()
	if err != nil {
		return nil, err
	}
	return toExamplePointers(examples), nil
}

// DictionaryEntry returns generated.DictionaryEntryResolver implementation.
func (r *Resolver) DictionaryEntry() generated.DictionaryEntryResolver {
	return &dictionaryEntryResolver{r}
}

// Sense returns generated.SenseResolver implementation.
func (r *Resolver) Sense() generated.SenseResolver { return &senseResolver{r} }

type dictionaryEntryResolver struct{ *Resolver }
type senseResolver struct{ *Resolver }

// Helper functions to convert value slices to pointer slices

func toSensePointers(senses []domain.Sense) []*domain.Sense {
	result := make([]*domain.Sense, len(senses))
	for i := range senses {
		result[i] = &senses[i]
	}
	return result
}

func toTranslationPointers(translations []domain.Translation) []*domain.Translation {
	result := make([]*domain.Translation, len(translations))
	for i := range translations {
		result[i] = &translations[i]
	}
	return result
}

func toExamplePointers(examples []domain.Example) []*domain.Example {
	result := make([]*domain.Example, len(examples))
	for i := range examples {
		result[i] = &examples[i]
	}
	return result
}

func toPronunciationPointers(prons []domain.RefPronunciation) []*domain.RefPronunciation {
	result := make([]*domain.RefPronunciation, len(prons))
	for i := range prons {
		result[i] = &prons[i]
	}
	return result
}

func toRefImagePointers(images []domain.RefImage) []*domain.RefImage {
	result := make([]*domain.RefImage, len(images))
	for i := range images {
		result[i] = &images[i]
	}
	return result
}

func toUserImagePointers(images []domain.UserImage) []*domain.UserImage {
	result := make([]*domain.UserImage, len(images))
	for i := range images {
		result[i] = &images[i]
	}
	return result
}

func toTopicPointers(topics []domain.Topic) []*domain.Topic {
	result := make([]*domain.Topic, len(topics))
	for i := range topics {
		result[i] = &topics[i]
	}
	return result
}
