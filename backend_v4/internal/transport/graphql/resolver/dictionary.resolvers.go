package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/heartmarshall/myenglish-backend/internal/domain"
	"github.com/heartmarshall/myenglish-backend/internal/service/dictionary"
	"github.com/heartmarshall/myenglish-backend/internal/transport/graphql/dataloader"
	"github.com/heartmarshall/myenglish-backend/internal/transport/graphql/generated"
	"github.com/heartmarshall/myenglish-backend/pkg/ctxutil"
)

// Senses is the resolver for the senses field.
func (r *dictionaryEntryResolver) Senses(ctx context.Context, obj *domain.Entry) ([]*domain.Sense, error) {
	if len(obj.Senses) > 0 {
		return toSensePointers(obj.Senses), nil
	}
	loaders := dataloader.FromContext(ctx)
	if loaders == nil {
		return nil, fmt.Errorf("dataloaders not in context")
	}
	senses, err := loaders.SensesByEntryID.Load(ctx, obj.ID)()
	if err != nil {
		return nil, err
	}
	return toSensePointers(senses), nil
}

// Pronunciations is the resolver for the pronunciations field.
func (r *dictionaryEntryResolver) Pronunciations(ctx context.Context, obj *domain.Entry) ([]*domain.RefPronunciation, error) {
	if len(obj.Pronunciations) > 0 {
		return toPronunciationPointers(obj.Pronunciations), nil
	}
	loaders := dataloader.FromContext(ctx)
	if loaders == nil {
		return nil, fmt.Errorf("dataloaders not in context")
	}
	prons, err := loaders.PronunciationsByEntryID.Load(ctx, obj.ID)()
	if err != nil {
		return nil, err
	}
	return toPronunciationPointers(prons), nil
}

// CatalogImages is the resolver for the catalogImages field.
func (r *dictionaryEntryResolver) CatalogImages(ctx context.Context, obj *domain.Entry) ([]*domain.RefImage, error) {
	if len(obj.CatalogImages) > 0 {
		return toRefImagePointers(obj.CatalogImages), nil
	}
	loaders := dataloader.FromContext(ctx)
	if loaders == nil {
		return nil, fmt.Errorf("dataloaders not in context")
	}
	images, err := loaders.CatalogImagesByEntryID.Load(ctx, obj.ID)()
	if err != nil {
		return nil, err
	}
	return toRefImagePointers(images), nil
}

// UserImages is the resolver for the userImages field.
func (r *dictionaryEntryResolver) UserImages(ctx context.Context, obj *domain.Entry) ([]*domain.UserImage, error) {
	if len(obj.UserImages) > 0 {
		return toUserImagePointers(obj.UserImages), nil
	}
	loaders := dataloader.FromContext(ctx)
	if loaders == nil {
		return nil, fmt.Errorf("dataloaders not in context")
	}
	images, err := loaders.UserImagesByEntryID.Load(ctx, obj.ID)()
	if err != nil {
		return nil, err
	}
	return toUserImagePointers(images), nil
}

// Card is the resolver for the card field.
func (r *dictionaryEntryResolver) Card(ctx context.Context, obj *domain.Entry) (*domain.Card, error) {
	if obj.Card != nil {
		return obj.Card, nil
	}
	loaders := dataloader.FromContext(ctx)
	if loaders == nil {
		return nil, fmt.Errorf("dataloaders not in context")
	}
	return loaders.CardByEntryID.Load(ctx, obj.ID)()
}

// Topics is the resolver for the topics field.
func (r *dictionaryEntryResolver) Topics(ctx context.Context, obj *domain.Entry) ([]*domain.Topic, error) {
	if len(obj.Topics) > 0 {
		return toTopicPointers(obj.Topics), nil
	}
	loaders := dataloader.FromContext(ctx)
	if loaders == nil {
		return nil, fmt.Errorf("dataloaders not in context")
	}
	topics, err := loaders.TopicsByEntryID.Load(ctx, obj.ID)()
	if err != nil {
		return nil, err
	}
	return toTopicPointers(topics), nil
}

// CreateEntryFromCatalog is the resolver for the createEntryFromCatalog field.
func (r *mutationResolver) CreateEntryFromCatalog(ctx context.Context, input generated.CreateEntryFromCatalogInput) (*generated.CreateEntryPayload, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	createCard := false
	if input.CreateCard != nil {
		createCard = *input.CreateCard
	}

	serviceInput := dictionary.CreateFromCatalogInput{
		RefEntryID: input.RefEntryID,
		SenseIDs:   input.SenseIds,
		CreateCard: createCard,
		Notes:      input.Notes,
	}

	entry, err := r.dictionary.CreateEntryFromCatalog(ctx, serviceInput)
	if err != nil {
		return nil, err
	}

	return &generated.CreateEntryPayload{Entry: entry}, nil
}

// CreateEntryCustom is the resolver for the createEntryCustom field.
func (r *mutationResolver) CreateEntryCustom(ctx context.Context, input generated.CreateEntryCustomInput) (*generated.CreateEntryPayload, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	createCard := false
	if input.CreateCard != nil {
		createCard = *input.CreateCard
	}

	// Map GraphQL input to service input
	senses := make([]dictionary.SenseInput, len(input.Senses))
	for i, s := range input.Senses {
		examples := make([]dictionary.ExampleInput, len(s.Examples))
		for j, ex := range s.Examples {
			examples[j] = dictionary.ExampleInput{
				Sentence:    ex.Sentence,
				Translation: ex.Translation,
			}
		}

		senses[i] = dictionary.SenseInput{
			Definition:   s.Definition,
			PartOfSpeech: s.PartOfSpeech,
			Translations: s.Translations,
			Examples:     examples,
		}
	}

	serviceInput := dictionary.CreateCustomInput{
		Text:       input.Text,
		Senses:     senses,
		CreateCard: createCard,
		Notes:      input.Notes,
	}

	entry, err := r.dictionary.CreateEntryCustom(ctx, serviceInput)
	if err != nil {
		return nil, err
	}

	return &generated.CreateEntryPayload{Entry: entry}, nil
}

// UpdateEntryNotes is the resolver for the updateEntryNotes field.
func (r *mutationResolver) UpdateEntryNotes(ctx context.Context, input generated.UpdateEntryNotesInput) (*generated.UpdateEntryPayload, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	serviceInput := dictionary.UpdateNotesInput{
		EntryID: input.EntryID,
		Notes:   input.Notes,
	}

	entry, err := r.dictionary.UpdateNotes(ctx, serviceInput)
	if err != nil {
		return nil, err
	}

	return &generated.UpdateEntryPayload{Entry: entry}, nil
}

// DeleteEntry is the resolver for the deleteEntry field.
func (r *mutationResolver) DeleteEntry(ctx context.Context, id uuid.UUID) (*generated.DeleteEntryPayload, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	err := r.dictionary.DeleteEntry(ctx, id)
	if err != nil {
		return nil, err
	}

	return &generated.DeleteEntryPayload{EntryID: id}, nil
}

// RestoreEntry is the resolver for the restoreEntry field.
func (r *mutationResolver) RestoreEntry(ctx context.Context, id uuid.UUID) (*generated.RestoreEntryPayload, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	entry, err := r.dictionary.RestoreEntry(ctx, id)
	if err != nil {
		return nil, err
	}

	return &generated.RestoreEntryPayload{Entry: entry}, nil
}

// BatchDeleteEntries is the resolver for the batchDeleteEntries field.
func (r *mutationResolver) BatchDeleteEntries(ctx context.Context, ids []uuid.UUID) (*generated.BatchDeletePayload, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	result, err := r.dictionary.BatchDeleteEntries(ctx, ids)
	if err != nil {
		return nil, err
	}

	// Map service errors to GraphQL errors
	errors := make([]*generated.BatchError, len(result.Errors))
	for i, e := range result.Errors {
		errors[i] = &generated.BatchError{
			ID:      e.EntryID,
			Message: e.Error,
		}
	}

	return &generated.BatchDeletePayload{
		DeletedCount: result.Deleted,
		Errors:       errors,
	}, nil
}

// ImportEntries is the resolver for the importEntries field.
func (r *mutationResolver) ImportEntries(ctx context.Context, input generated.ImportEntriesInput) (*generated.ImportPayload, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	// Map GraphQL input to service input
	items := make([]dictionary.ImportItem, len(input.Items))
	for i, item := range input.Items {
		items[i] = dictionary.ImportItem{
			Text:         item.Text,
			Translations: item.Translations,
			Notes:        item.Notes,
			TopicName:    item.TopicName,
		}
	}

	serviceInput := dictionary.ImportInput{
		Items: items,
	}

	result, err := r.dictionary.ImportEntries(ctx, serviceInput)
	if err != nil {
		return nil, err
	}

	// Map service errors to GraphQL errors
	errors := make([]*generated.ImportError, len(result.Errors))
	for i, e := range result.Errors {
		errors[i] = &generated.ImportError{
			Index:   e.LineNumber,
			Text:    e.Text,
			Message: e.Reason,
		}
	}

	return &generated.ImportPayload{
		ImportedCount: result.Imported,
		SkippedCount:  result.Skipped,
		Errors:        errors,
	}, nil
}

// SearchCatalog is the resolver for the searchCatalog field.
func (r *queryResolver) SearchCatalog(ctx context.Context, query string, limit *int) ([]*domain.RefEntry, error) {
	// No auth required - public RefCatalog
	l := 10 // default
	if limit != nil {
		l = *limit
	}

	entries, err := r.dictionary.SearchCatalog(ctx, query, l)
	if err != nil {
		return nil, err
	}

	// Convert []domain.RefEntry to []*domain.RefEntry
	result := make([]*domain.RefEntry, len(entries))
	for i := range entries {
		result[i] = &entries[i]
	}
	return result, nil
}

// PreviewRefEntry is the resolver for the previewRefEntry field.
func (r *queryResolver) PreviewRefEntry(ctx context.Context, text string) (*domain.RefEntry, error) {
	// No auth required - public RefCatalog
	return r.dictionary.PreviewRefEntry(ctx, text)
}

// Dictionary is the resolver for the dictionary field.
func (r *queryResolver) Dictionary(ctx context.Context, input generated.DictionaryFilterInput) (*generated.DictionaryConnection, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	// Map GraphQL input to service input
	serviceInput := dictionary.FindInput{
		Search:       input.Search,
		HasCard:      input.HasCard,
		PartOfSpeech: input.PartOfSpeech,
		TopicID:      input.TopicID,
		Status:       input.Status,
	}

	// Map sort fields
	if input.SortField != nil {
		switch *input.SortField {
		case generated.EntrySortFieldText:
			serviceInput.SortBy = "text"
		case generated.EntrySortFieldCreatedAt:
			serviceInput.SortBy = "created_at"
		case generated.EntrySortFieldUpdatedAt:
			serviceInput.SortBy = "updated_at"
		}
	}

	if input.SortDirection != nil {
		switch *input.SortDirection {
		case generated.SortDirectionAsc:
			serviceInput.SortOrder = "ASC"
		case generated.SortDirectionDesc:
			serviceInput.SortOrder = "DESC"
		}
	}

	// Prioritize cursor-based pagination if after is provided
	if input.After != nil {
		serviceInput.Cursor = input.After
		if input.First != nil {
			serviceInput.Limit = *input.First
		} else {
			serviceInput.Limit = 20 // default for cursor-based
		}
	} else {
		// Offset-based pagination
		if input.Limit != nil {
			serviceInput.Limit = *input.Limit
		} else {
			serviceInput.Limit = 20 // default
		}
		if input.Offset != nil {
			serviceInput.Offset = input.Offset
		}
	}

	result, err := r.dictionary.FindEntries(ctx, serviceInput)
	if err != nil {
		return nil, err
	}

	// Build Connection (edges, pageInfo, totalCount)
	edges := make([]*generated.DictionaryEdge, len(result.Entries))
	for i := range result.Entries {
		edges[i] = &generated.DictionaryEdge{
			Node:   &result.Entries[i],
			Cursor: encodeCursor(result.Entries[i].ID.String()),
		}
	}

	pageInfo := &generated.PageInfo{
		HasNextPage:     result.HasNextPage,
		HasPreviousPage: false, // backward pagination not supported
	}

	// Use service-provided cursors if available
	if result.PageInfo != nil {
		pageInfo.StartCursor = result.PageInfo.StartCursor
		pageInfo.EndCursor = result.PageInfo.EndCursor
	}

	return &generated.DictionaryConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: result.TotalCount,
	}, nil
}

// DictionaryEntry is the resolver for the dictionaryEntry field.
func (r *queryResolver) DictionaryEntry(ctx context.Context, id uuid.UUID) (*domain.Entry, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	return r.dictionary.GetEntry(ctx, id)
}

// DeletedEntries is the resolver for the deletedEntries field.
func (r *queryResolver) DeletedEntries(ctx context.Context, limit *int, offset *int) (*generated.DeletedEntriesList, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	l := 50 // default limit
	if limit != nil {
		l = *limit
	}

	o := 0 // default offset
	if offset != nil {
		o = *offset
	}

	entries, totalCount, err := r.dictionary.FindDeletedEntries(ctx, l, o)
	if err != nil {
		return nil, err
	}

	// Convert []domain.Entry to []*domain.Entry
	result := make([]*domain.Entry, len(entries))
	for i := range entries {
		result[i] = &entries[i]
	}

	return &generated.DeletedEntriesList{
		Entries:    result,
		TotalCount: totalCount,
	}, nil
}

// ExportEntries is the resolver for the exportEntries field.
func (r *queryResolver) ExportEntries(ctx context.Context) (*dictionary.ExportResult, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	return r.dictionary.ExportEntries(ctx)
}

// Translations is the resolver for the translations field.
func (r *senseResolver) Translations(ctx context.Context, obj *domain.Sense) ([]*domain.Translation, error) {
	if len(obj.Translations) > 0 {
		return toTranslationPointers(obj.Translations), nil
	}
	loaders := dataloader.FromContext(ctx)
	if loaders == nil {
		return nil, fmt.Errorf("dataloaders not in context")
	}
	translations, err := loaders.TranslationsBySenseID.Load(ctx, obj.ID)()
	if err != nil {
		return nil, err
	}
	return toTranslationPointers(translations), nil
}

// Examples is the resolver for the examples field.
func (r *senseResolver) Examples(ctx context.Context, obj *domain.Sense) ([]*domain.Example, error) {
	if len(obj.Examples) > 0 {
		return toExamplePointers(obj.Examples), nil
	}
	loaders := dataloader.FromContext(ctx)
	if loaders == nil {
		return nil, fmt.Errorf("dataloaders not in context")
	}
	examples, err := loaders.ExamplesBySenseID.Load(ctx, obj.ID)()
	if err != nil {
		return nil, err
	}
	return toExamplePointers(examples), nil
}

// DictionaryEntry returns generated.DictionaryEntryResolver implementation.
func (r *Resolver) DictionaryEntry() generated.DictionaryEntryResolver {
	return &dictionaryEntryResolver{r}
}

// Sense returns generated.SenseResolver implementation.
func (r *Resolver) Sense() generated.SenseResolver { return &senseResolver{r} }

type dictionaryEntryResolver struct{ *Resolver }
type senseResolver struct{ *Resolver }

// Helper functions to convert value slices to pointer slices

func toSensePointers(senses []domain.Sense) []*domain.Sense {
	result := make([]*domain.Sense, len(senses))
	for i := range senses {
		result[i] = &senses[i]
	}
	return result
}

func toTranslationPointers(translations []domain.Translation) []*domain.Translation {
	result := make([]*domain.Translation, len(translations))
	for i := range translations {
		result[i] = &translations[i]
	}
	return result
}

func toExamplePointers(examples []domain.Example) []*domain.Example {
	result := make([]*domain.Example, len(examples))
	for i := range examples {
		result[i] = &examples[i]
	}
	return result
}

func toPronunciationPointers(prons []domain.RefPronunciation) []*domain.RefPronunciation {
	result := make([]*domain.RefPronunciation, len(prons))
	for i := range prons {
		result[i] = &prons[i]
	}
	return result
}

func toRefImagePointers(images []domain.RefImage) []*domain.RefImage {
	result := make([]*domain.RefImage, len(images))
	for i := range images {
		result[i] = &images[i]
	}
	return result
}

func toUserImagePointers(images []domain.UserImage) []*domain.UserImage {
	result := make([]*domain.UserImage, len(images))
	for i := range images {
		result[i] = &images[i]
	}
	return result
}

func toTopicPointers(topics []domain.Topic) []*domain.Topic {
	result := make([]*domain.Topic, len(topics))
	for i := range topics {
		result[i] = &topics[i]
	}
	return result
}
