package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/heartmarshall/myenglish-backend/internal/domain"
	"github.com/heartmarshall/myenglish-backend/internal/service/dictionary"
	"github.com/heartmarshall/myenglish-backend/internal/transport/graphql/generated"
)

// Senses is the resolver for the senses field.
func (r *dictionaryEntryResolver) Senses(ctx context.Context, obj *domain.Entry) ([]*domain.Sense, error) {
	panic(fmt.Errorf("not implemented: Senses - senses"))
}

// Pronunciations is the resolver for the pronunciations field.
func (r *dictionaryEntryResolver) Pronunciations(ctx context.Context, obj *domain.Entry) ([]*domain.RefPronunciation, error) {
	panic(fmt.Errorf("not implemented: Pronunciations - pronunciations"))
}

// CatalogImages is the resolver for the catalogImages field.
func (r *dictionaryEntryResolver) CatalogImages(ctx context.Context, obj *domain.Entry) ([]*domain.RefImage, error) {
	panic(fmt.Errorf("not implemented: CatalogImages - catalogImages"))
}

// UserImages is the resolver for the userImages field.
func (r *dictionaryEntryResolver) UserImages(ctx context.Context, obj *domain.Entry) ([]*domain.UserImage, error) {
	panic(fmt.Errorf("not implemented: UserImages - userImages"))
}

// Card is the resolver for the card field.
func (r *dictionaryEntryResolver) Card(ctx context.Context, obj *domain.Entry) (*domain.Card, error) {
	panic(fmt.Errorf("not implemented: Card - card"))
}

// Topics is the resolver for the topics field.
func (r *dictionaryEntryResolver) Topics(ctx context.Context, obj *domain.Entry) ([]*domain.Topic, error) {
	panic(fmt.Errorf("not implemented: Topics - topics"))
}

// CreateEntryFromCatalog is the resolver for the createEntryFromCatalog field.
func (r *mutationResolver) CreateEntryFromCatalog(ctx context.Context, input generated.CreateEntryFromCatalogInput) (*generated.CreateEntryPayload, error) {
	panic(fmt.Errorf("not implemented: CreateEntryFromCatalog - createEntryFromCatalog"))
}

// CreateEntryCustom is the resolver for the createEntryCustom field.
func (r *mutationResolver) CreateEntryCustom(ctx context.Context, input generated.CreateEntryCustomInput) (*generated.CreateEntryPayload, error) {
	panic(fmt.Errorf("not implemented: CreateEntryCustom - createEntryCustom"))
}

// UpdateEntryNotes is the resolver for the updateEntryNotes field.
func (r *mutationResolver) UpdateEntryNotes(ctx context.Context, input generated.UpdateEntryNotesInput) (*generated.UpdateEntryPayload, error) {
	panic(fmt.Errorf("not implemented: UpdateEntryNotes - updateEntryNotes"))
}

// DeleteEntry is the resolver for the deleteEntry field.
func (r *mutationResolver) DeleteEntry(ctx context.Context, id uuid.UUID) (*generated.DeleteEntryPayload, error) {
	panic(fmt.Errorf("not implemented: DeleteEntry - deleteEntry"))
}

// RestoreEntry is the resolver for the restoreEntry field.
func (r *mutationResolver) RestoreEntry(ctx context.Context, id uuid.UUID) (*generated.RestoreEntryPayload, error) {
	panic(fmt.Errorf("not implemented: RestoreEntry - restoreEntry"))
}

// BatchDeleteEntries is the resolver for the batchDeleteEntries field.
func (r *mutationResolver) BatchDeleteEntries(ctx context.Context, ids []uuid.UUID) (*generated.BatchDeletePayload, error) {
	panic(fmt.Errorf("not implemented: BatchDeleteEntries - batchDeleteEntries"))
}

// ImportEntries is the resolver for the importEntries field.
func (r *mutationResolver) ImportEntries(ctx context.Context, input generated.ImportEntriesInput) (*generated.ImportPayload, error) {
	panic(fmt.Errorf("not implemented: ImportEntries - importEntries"))
}

// SearchCatalog is the resolver for the searchCatalog field.
func (r *queryResolver) SearchCatalog(ctx context.Context, query string, limit *int) ([]*domain.RefEntry, error) {
	panic(fmt.Errorf("not implemented: SearchCatalog - searchCatalog"))
}

// PreviewRefEntry is the resolver for the previewRefEntry field.
func (r *queryResolver) PreviewRefEntry(ctx context.Context, text string) (*domain.RefEntry, error) {
	panic(fmt.Errorf("not implemented: PreviewRefEntry - previewRefEntry"))
}

// Dictionary is the resolver for the dictionary field.
func (r *queryResolver) Dictionary(ctx context.Context, input generated.DictionaryFilterInput) (*generated.DictionaryConnection, error) {
	panic(fmt.Errorf("not implemented: Dictionary - dictionary"))
}

// DictionaryEntry is the resolver for the dictionaryEntry field.
func (r *queryResolver) DictionaryEntry(ctx context.Context, id uuid.UUID) (*domain.Entry, error) {
	panic(fmt.Errorf("not implemented: DictionaryEntry - dictionaryEntry"))
}

// DeletedEntries is the resolver for the deletedEntries field.
func (r *queryResolver) DeletedEntries(ctx context.Context, limit *int, offset *int) (*generated.DeletedEntriesList, error) {
	panic(fmt.Errorf("not implemented: DeletedEntries - deletedEntries"))
}

// ExportEntries is the resolver for the exportEntries field.
func (r *queryResolver) ExportEntries(ctx context.Context) (*dictionary.ExportResult, error) {
	panic(fmt.Errorf("not implemented: ExportEntries - exportEntries"))
}

// Translations is the resolver for the translations field.
func (r *senseResolver) Translations(ctx context.Context, obj *domain.Sense) ([]*domain.Translation, error) {
	panic(fmt.Errorf("not implemented: Translations - translations"))
}

// Examples is the resolver for the examples field.
func (r *senseResolver) Examples(ctx context.Context, obj *domain.Sense) ([]*domain.Example, error) {
	panic(fmt.Errorf("not implemented: Examples - examples"))
}

// DictionaryEntry returns generated.DictionaryEntryResolver implementation.
func (r *Resolver) DictionaryEntry() generated.DictionaryEntryResolver {
	return &dictionaryEntryResolver{r}
}

// Sense returns generated.SenseResolver implementation.
func (r *Resolver) Sense() generated.SenseResolver { return &senseResolver{r} }

type dictionaryEntryResolver struct{ *Resolver }
type senseResolver struct{ *Resolver }
