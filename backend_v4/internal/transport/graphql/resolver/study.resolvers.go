package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"

	"github.com/google/uuid"
	"github.com/heartmarshall/myenglish-backend/internal/domain"
	"github.com/heartmarshall/myenglish-backend/internal/service/study"
	"github.com/heartmarshall/myenglish-backend/internal/transport/graphql/generated"
	"github.com/heartmarshall/myenglish-backend/pkg/ctxutil"
)

// AverageDurationMs is the resolver for the averageDurationMs field.
func (r *cardStatsResolver) AverageDurationMs(ctx context.Context, obj *domain.CardStats) (int, error) {
	if obj.AverageTimeMs == nil {
		return 0, nil
	}
	return *obj.AverageTimeMs, nil
}

// Accuracy is the resolver for the accuracy field.
func (r *cardStatsResolver) Accuracy(ctx context.Context, obj *domain.CardStats) (float64, error) {
	return obj.AccuracyRate, nil
}

// ReviewCard is the resolver for the reviewCard field.
func (r *mutationResolver) ReviewCard(ctx context.Context, input generated.ReviewCardInput) (*generated.ReviewCardPayload, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	serviceInput := study.ReviewCardInput{
		CardID:     input.CardID,
		Grade:      input.Grade,
		DurationMs: input.DurationMs,
	}

	card, err := r.study.ReviewCard(ctx, serviceInput)
	if err != nil {
		return nil, err
	}

	return &generated.ReviewCardPayload{Card: card}, nil
}

// UndoReview is the resolver for the undoReview field.
func (r *mutationResolver) UndoReview(ctx context.Context, cardID uuid.UUID) (*generated.UndoReviewPayload, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	serviceInput := study.UndoReviewInput{CardID: cardID}
	card, err := r.study.UndoReview(ctx, serviceInput)
	if err != nil {
		return nil, err
	}

	return &generated.UndoReviewPayload{Card: card}, nil
}

// CreateCard is the resolver for the createCard field.
func (r *mutationResolver) CreateCard(ctx context.Context, entryID uuid.UUID) (*generated.CreateCardPayload, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	serviceInput := study.CreateCardInput{EntryID: entryID}
	card, err := r.study.CreateCard(ctx, serviceInput)
	if err != nil {
		return nil, err
	}

	return &generated.CreateCardPayload{Card: card}, nil
}

// DeleteCard is the resolver for the deleteCard field.
func (r *mutationResolver) DeleteCard(ctx context.Context, id uuid.UUID) (*generated.DeleteCardPayload, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	serviceInput := study.DeleteCardInput{CardID: id}
	err := r.study.DeleteCard(ctx, serviceInput)
	if err != nil {
		return nil, err
	}

	return &generated.DeleteCardPayload{CardID: id}, nil
}

// BatchCreateCards is the resolver for the batchCreateCards field.
func (r *mutationResolver) BatchCreateCards(ctx context.Context, entryIds []uuid.UUID) (*generated.BatchCreateCardsPayload, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	serviceInput := study.BatchCreateCardsInput{EntryIDs: entryIds}
	result, err := r.study.BatchCreateCards(ctx, serviceInput)
	if err != nil {
		return nil, err
	}

	errors := make([]*generated.BatchCreateCardError, len(result.Errors))
	for i, e := range result.Errors {
		errors[i] = &generated.BatchCreateCardError{
			EntryID: e.EntryID,
			Message: e.Reason,
		}
	}

	return &generated.BatchCreateCardsPayload{
		CreatedCount:    result.Created,
		SkippedExisting: result.SkippedExisting,
		SkippedNoSenses: result.SkippedNoSenses,
		Errors:          errors,
	}, nil
}

// StartStudySession is the resolver for the startStudySession field.
func (r *mutationResolver) StartStudySession(ctx context.Context) (*generated.StartSessionPayload, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	session, err := r.study.StartSession(ctx)
	if err != nil {
		return nil, err
	}

	return &generated.StartSessionPayload{Session: session}, nil
}

// FinishStudySession is the resolver for the finishStudySession field.
func (r *mutationResolver) FinishStudySession(ctx context.Context) (*generated.FinishSessionPayload, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	session, err := r.study.FinishActiveSession(ctx)
	if err != nil {
		return nil, err
	}

	return &generated.FinishSessionPayload{Session: session}, nil
}

// AbandonStudySession is the resolver for the abandonStudySession field.
func (r *mutationResolver) AbandonStudySession(ctx context.Context) (*generated.AbandonSessionPayload, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	err := r.study.AbandonSession(ctx)
	if err != nil {
		return nil, err
	}

	return &generated.AbandonSessionPayload{Success: true}, nil
}

// StudyQueue is the resolver for the studyQueue field.
func (r *queryResolver) StudyQueue(ctx context.Context, limit *int) ([]*domain.Entry, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	l := 50
	if limit != nil {
		l = *limit
	}

	serviceInput := study.GetQueueInput{Limit: l}
	return r.study.GetStudyQueueEntries(ctx, serviceInput)
}

// Dashboard is the resolver for the dashboard field.
func (r *queryResolver) Dashboard(ctx context.Context) (*domain.Dashboard, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	dashboard, err := r.study.GetDashboard(ctx)
	if err != nil {
		return nil, err
	}

	return &dashboard, nil
}

// CardHistory is the resolver for the cardHistory field.
func (r *queryResolver) CardHistory(ctx context.Context, input generated.GetCardHistoryInput) (*generated.CardHistoryPayload, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	limit := 50
	if input.Limit != nil {
		limit = *input.Limit
	}

	offset := 0
	if input.Offset != nil {
		offset = *input.Offset
	}

	serviceInput := study.GetCardHistoryInput{
		CardID: input.CardID,
		Limit:  limit,
		Offset: offset,
	}

	logs, total, err := r.study.GetCardHistory(ctx, serviceInput)
	if err != nil {
		return nil, err
	}

	return &generated.CardHistoryPayload{
		Logs:       logs,
		TotalCount: total,
	}, nil
}

// CardStats is the resolver for the cardStats field.
func (r *queryResolver) CardStats(ctx context.Context, cardID uuid.UUID) (*domain.CardStats, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	input := study.GetCardHistoryInput{CardID: cardID}
	stats, err := r.study.GetCardStats(ctx, input)
	if err != nil {
		return nil, err
	}

	return &stats, nil
}

// PrevState is the resolver for the prevState field.
func (r *reviewLogResolver) PrevState(ctx context.Context, obj *domain.ReviewLog) (*generated.CardSnapshotOutput, error) {
	if obj.PrevState == nil {
		return nil, nil
	}
	return &generated.CardSnapshotOutput{
		State:         obj.PrevState.State,
		Step:          obj.PrevState.Step,
		Stability:     obj.PrevState.Stability,
		Difficulty:    obj.PrevState.Difficulty,
		ScheduledDays: obj.PrevState.ScheduledDays,
	}, nil
}

// TotalReviews is the resolver for the totalReviews field.
func (r *sessionResultResolver) TotalReviews(ctx context.Context, obj *domain.SessionResult) (int, error) {
	return obj.TotalReviewed, nil
}

// TotalDurationMs is the resolver for the totalDurationMs field.
func (r *sessionResultResolver) TotalDurationMs(ctx context.Context, obj *domain.SessionResult) (int, error) {
	return int(obj.DurationMs), nil
}

// CardStats returns generated.CardStatsResolver implementation.
func (r *Resolver) CardStats() generated.CardStatsResolver { return &cardStatsResolver{r} }

// ReviewLog returns generated.ReviewLogResolver implementation.
func (r *Resolver) ReviewLog() generated.ReviewLogResolver { return &reviewLogResolver{r} }

// SessionResult returns generated.SessionResultResolver implementation.
func (r *Resolver) SessionResult() generated.SessionResultResolver { return &sessionResultResolver{r} }

type cardStatsResolver struct{ *Resolver }
type reviewLogResolver struct{ *Resolver }
type sessionResultResolver struct{ *Resolver }
