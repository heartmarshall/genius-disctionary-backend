package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/heartmarshall/myenglish-backend/internal/domain"
	"github.com/heartmarshall/myenglish-backend/internal/service/study"
	"github.com/heartmarshall/myenglish-backend/internal/transport/graphql/generated"
	"github.com/heartmarshall/myenglish-backend/pkg/ctxutil"
)

// AverageDurationMs is the resolver for the averageDurationMs field.
func (r *cardStatsResolver) AverageDurationMs(ctx context.Context, obj *domain.CardStats) (int, error) {
	if obj.AverageTimeMs == nil {
		return 0, nil
	}
	return *obj.AverageTimeMs, nil
}

// Accuracy is the resolver for the accuracy field.
func (r *cardStatsResolver) Accuracy(ctx context.Context, obj *domain.CardStats) (float64, error) {
	return obj.AccuracyRate, nil
}

// ActiveSession is the resolver for the activeSession field.
func (r *dashboardResolver) ActiveSession(ctx context.Context, obj *domain.Dashboard) (*domain.StudySession, error) {
	if obj.ActiveSession == nil {
		return nil, nil
	}

	session, err := r.study.GetActiveSession(ctx)
	if err != nil {
		return nil, err
	}
	return session, nil
}

// ReviewCard is the resolver for the reviewCard field.
func (r *mutationResolver) ReviewCard(ctx context.Context, input generated.ReviewCardInput) (*generated.ReviewCardPayload, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	serviceInput := study.ReviewCardInput{
		CardID:     input.CardID,
		Grade:      input.Grade,
		DurationMs: input.DurationMs,
		SessionID:  nil, // GraphQL doesn't have sessionID in ReviewCardInput
	}

	card, err := r.study.ReviewCard(ctx, serviceInput)
	if err != nil {
		return nil, err
	}

	return &generated.ReviewCardPayload{Card: card}, nil
}

// UndoReview is the resolver for the undoReview field.
func (r *mutationResolver) UndoReview(ctx context.Context, cardID uuid.UUID) (*generated.UndoReviewPayload, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	serviceInput := study.UndoReviewInput{CardID: cardID}
	card, err := r.study.UndoReview(ctx, serviceInput)
	if err != nil {
		return nil, err
	}

	return &generated.UndoReviewPayload{Card: card}, nil
}

// CreateCard is the resolver for the createCard field.
func (r *mutationResolver) CreateCard(ctx context.Context, entryID uuid.UUID) (*generated.CreateCardPayload, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	serviceInput := study.CreateCardInput{EntryID: entryID}
	card, err := r.study.CreateCard(ctx, serviceInput)
	if err != nil {
		return nil, err
	}

	return &generated.CreateCardPayload{Card: card}, nil
}

// DeleteCard is the resolver for the deleteCard field.
func (r *mutationResolver) DeleteCard(ctx context.Context, id uuid.UUID) (*generated.DeleteCardPayload, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	serviceInput := study.DeleteCardInput{CardID: id}
	err := r.study.DeleteCard(ctx, serviceInput)
	if err != nil {
		return nil, err
	}

	return &generated.DeleteCardPayload{CardID: id}, nil
}

// BatchCreateCards is the resolver for the batchCreateCards field.
func (r *mutationResolver) BatchCreateCards(ctx context.Context, entryIds []uuid.UUID) (*generated.BatchCreateCardsPayload, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	serviceInput := study.BatchCreateCardsInput{EntryIDs: entryIds}
	result, err := r.study.BatchCreateCards(ctx, serviceInput)
	if err != nil {
		return nil, err
	}

	skippedCount := result.SkippedExisting + result.SkippedNoSenses

	errors := make([]*generated.BatchCreateCardError, len(result.Errors))
	for i, e := range result.Errors {
		errors[i] = &generated.BatchCreateCardError{
			EntryID: e.EntryID,
			Message: e.Reason,
		}
	}

	return &generated.BatchCreateCardsPayload{
		CreatedCount: result.Created,
		SkippedCount: skippedCount,
		Errors:       errors,
	}, nil
}

// StartStudySession is the resolver for the startStudySession field.
func (r *mutationResolver) StartStudySession(ctx context.Context) (*generated.StartSessionPayload, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	session, err := r.study.StartSession(ctx)
	if err != nil {
		return nil, err
	}

	return &generated.StartSessionPayload{Session: session}, nil
}

// FinishStudySession is the resolver for the finishStudySession field.
func (r *mutationResolver) FinishStudySession(ctx context.Context, input generated.FinishSessionInput) (*generated.FinishSessionPayload, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	serviceInput := study.FinishSessionInput{SessionID: input.SessionID}
	session, err := r.study.FinishSession(ctx, serviceInput)
	if err != nil {
		return nil, err
	}

	return &generated.FinishSessionPayload{Session: session}, nil
}

// AbandonStudySession is the resolver for the abandonStudySession field.
func (r *mutationResolver) AbandonStudySession(ctx context.Context) (*generated.AbandonSessionPayload, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	err := r.study.AbandonSession(ctx)
	if err != nil {
		return nil, err
	}

	return &generated.AbandonSessionPayload{Success: true}, nil
}

// StudyQueue is the resolver for the studyQueue field.
func (r *queryResolver) StudyQueue(ctx context.Context, limit *int) ([]*domain.Entry, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	l := 20
	if limit != nil {
		l = *limit
	}

	serviceInput := study.GetQueueInput{Limit: l}
	cards, err := r.study.GetStudyQueue(ctx, serviceInput)
	if err != nil {
		return nil, err
	}

	// Load entries for each card
	entries := make([]*domain.Entry, len(cards))
	for i, card := range cards {
		entry, err := r.dictionary.GetEntry(ctx, card.EntryID)
		if err != nil {
			return nil, fmt.Errorf("failed to load entry for card %s: %w", card.ID, err)
		}
		entries[i] = entry
	}

	return entries, nil
}

// Dashboard is the resolver for the dashboard field.
func (r *queryResolver) Dashboard(ctx context.Context) (*domain.Dashboard, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	dashboard, err := r.study.GetDashboard(ctx)
	if err != nil {
		return nil, err
	}

	return &dashboard, nil
}

// CardHistory is the resolver for the cardHistory field.
func (r *queryResolver) CardHistory(ctx context.Context, input generated.GetCardHistoryInput) ([]*domain.ReviewLog, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	limit := 50
	if input.Limit != nil {
		limit = *input.Limit
	}

	offset := 0
	if input.Offset != nil {
		offset = *input.Offset
	}

	serviceInput := study.GetCardHistoryInput{
		CardID: input.CardID,
		Limit:  limit,
		Offset: offset,
	}

	logs, _, err := r.study.GetCardHistory(ctx, serviceInput)
	if err != nil {
		return nil, err
	}

	return logs, nil
}

// CardStats is the resolver for the cardStats field.
func (r *queryResolver) CardStats(ctx context.Context, cardID uuid.UUID) (*domain.CardStats, error) {
	_, ok := ctxutil.UserIDFromCtx(ctx)
	if !ok {
		return nil, domain.ErrUnauthorized
	}

	input := study.GetCardHistoryInput{CardID: cardID}
	stats, err := r.study.GetCardStats(ctx, input)
	if err != nil {
		return nil, err
	}

	return &stats, nil
}

// TotalReviews is the resolver for the totalReviews field.
func (r *sessionResultResolver) TotalReviews(ctx context.Context, obj *domain.SessionResult) (int, error) {
	return obj.TotalReviewed, nil
}

// AverageDurationMs is the resolver for the averageDurationMs field.
func (r *sessionResultResolver) AverageDurationMs(ctx context.Context, obj *domain.SessionResult) (int, error) {
	return int(obj.DurationMs), nil
}

// CardStats returns generated.CardStatsResolver implementation.
func (r *Resolver) CardStats() generated.CardStatsResolver { return &cardStatsResolver{r} }

// Dashboard returns generated.DashboardResolver implementation.
func (r *Resolver) Dashboard() generated.DashboardResolver { return &dashboardResolver{r} }

// SessionResult returns generated.SessionResultResolver implementation.
func (r *Resolver) SessionResult() generated.SessionResultResolver { return &sessionResultResolver{r} }

type cardStatsResolver struct{ *Resolver }
type dashboardResolver struct{ *Resolver }
type sessionResultResolver struct{ *Resolver }
