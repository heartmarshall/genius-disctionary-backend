// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package resolver

import (
	"context"
	"github.com/google/uuid"
	"github.com/heartmarshall/myenglish-backend/internal/domain"
	"github.com/heartmarshall/myenglish-backend/internal/service/inbox"
	"sync"
)

// Ensure, that inboxServiceMock does implement inboxService.
// If this is not the case, regenerate this file with moq.
var _ inboxService = &inboxServiceMock{}

// inboxServiceMock is a mock implementation of inboxService.
//
//	func TestSomethingThatUsesinboxService(t *testing.T) {
//
//		// make and configure a mocked inboxService
//		mockedinboxService := &inboxServiceMock{
//			CreateItemFunc: func(ctx context.Context, input inbox.CreateItemInput) (*domain.InboxItem, error) {
//				panic("mock out the CreateItem method")
//			},
//			DeleteAllFunc: func(ctx context.Context) (int, error) {
//				panic("mock out the DeleteAll method")
//			},
//			DeleteItemFunc: func(ctx context.Context, input inbox.DeleteItemInput) error {
//				panic("mock out the DeleteItem method")
//			},
//			GetItemFunc: func(ctx context.Context, itemID uuid.UUID) (*domain.InboxItem, error) {
//				panic("mock out the GetItem method")
//			},
//			ListItemsFunc: func(ctx context.Context, input inbox.ListItemsInput) ([]*domain.InboxItem, int, error) {
//				panic("mock out the ListItems method")
//			},
//		}
//
//		// use mockedinboxService in code that requires inboxService
//		// and then make assertions.
//
//	}
type inboxServiceMock struct {
	// CreateItemFunc mocks the CreateItem method.
	CreateItemFunc func(ctx context.Context, input inbox.CreateItemInput) (*domain.InboxItem, error)

	// DeleteAllFunc mocks the DeleteAll method.
	DeleteAllFunc func(ctx context.Context) (int, error)

	// DeleteItemFunc mocks the DeleteItem method.
	DeleteItemFunc func(ctx context.Context, input inbox.DeleteItemInput) error

	// GetItemFunc mocks the GetItem method.
	GetItemFunc func(ctx context.Context, itemID uuid.UUID) (*domain.InboxItem, error)

	// ListItemsFunc mocks the ListItems method.
	ListItemsFunc func(ctx context.Context, input inbox.ListItemsInput) ([]*domain.InboxItem, int, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateItem holds details about calls to the CreateItem method.
		CreateItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input inbox.CreateItemInput
		}
		// DeleteAll holds details about calls to the DeleteAll method.
		DeleteAll []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// DeleteItem holds details about calls to the DeleteItem method.
		DeleteItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input inbox.DeleteItemInput
		}
		// GetItem holds details about calls to the GetItem method.
		GetItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ItemID is the itemID argument value.
			ItemID uuid.UUID
		}
		// ListItems holds details about calls to the ListItems method.
		ListItems []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input inbox.ListItemsInput
		}
	}
	lockCreateItem sync.RWMutex
	lockDeleteAll  sync.RWMutex
	lockDeleteItem sync.RWMutex
	lockGetItem    sync.RWMutex
	lockListItems  sync.RWMutex
}

// CreateItem calls CreateItemFunc.
func (mock *inboxServiceMock) CreateItem(ctx context.Context, input inbox.CreateItemInput) (*domain.InboxItem, error) {
	if mock.CreateItemFunc == nil {
		panic("inboxServiceMock.CreateItemFunc: method is nil but inboxService.CreateItem was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Input inbox.CreateItemInput
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockCreateItem.Lock()
	mock.calls.CreateItem = append(mock.calls.CreateItem, callInfo)
	mock.lockCreateItem.Unlock()
	return mock.CreateItemFunc(ctx, input)
}

// CreateItemCalls gets all the calls that were made to CreateItem.
// Check the length with:
//
//	len(mockedinboxService.CreateItemCalls())
func (mock *inboxServiceMock) CreateItemCalls() []struct {
	Ctx   context.Context
	Input inbox.CreateItemInput
} {
	var calls []struct {
		Ctx   context.Context
		Input inbox.CreateItemInput
	}
	mock.lockCreateItem.RLock()
	calls = mock.calls.CreateItem
	mock.lockCreateItem.RUnlock()
	return calls
}

// DeleteAll calls DeleteAllFunc.
func (mock *inboxServiceMock) DeleteAll(ctx context.Context) (int, error) {
	if mock.DeleteAllFunc == nil {
		panic("inboxServiceMock.DeleteAllFunc: method is nil but inboxService.DeleteAll was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockDeleteAll.Lock()
	mock.calls.DeleteAll = append(mock.calls.DeleteAll, callInfo)
	mock.lockDeleteAll.Unlock()
	return mock.DeleteAllFunc(ctx)
}

// DeleteAllCalls gets all the calls that were made to DeleteAll.
// Check the length with:
//
//	len(mockedinboxService.DeleteAllCalls())
func (mock *inboxServiceMock) DeleteAllCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockDeleteAll.RLock()
	calls = mock.calls.DeleteAll
	mock.lockDeleteAll.RUnlock()
	return calls
}

// DeleteItem calls DeleteItemFunc.
func (mock *inboxServiceMock) DeleteItem(ctx context.Context, input inbox.DeleteItemInput) error {
	if mock.DeleteItemFunc == nil {
		panic("inboxServiceMock.DeleteItemFunc: method is nil but inboxService.DeleteItem was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Input inbox.DeleteItemInput
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockDeleteItem.Lock()
	mock.calls.DeleteItem = append(mock.calls.DeleteItem, callInfo)
	mock.lockDeleteItem.Unlock()
	return mock.DeleteItemFunc(ctx, input)
}

// DeleteItemCalls gets all the calls that were made to DeleteItem.
// Check the length with:
//
//	len(mockedinboxService.DeleteItemCalls())
func (mock *inboxServiceMock) DeleteItemCalls() []struct {
	Ctx   context.Context
	Input inbox.DeleteItemInput
} {
	var calls []struct {
		Ctx   context.Context
		Input inbox.DeleteItemInput
	}
	mock.lockDeleteItem.RLock()
	calls = mock.calls.DeleteItem
	mock.lockDeleteItem.RUnlock()
	return calls
}

// GetItem calls GetItemFunc.
func (mock *inboxServiceMock) GetItem(ctx context.Context, itemID uuid.UUID) (*domain.InboxItem, error) {
	if mock.GetItemFunc == nil {
		panic("inboxServiceMock.GetItemFunc: method is nil but inboxService.GetItem was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		ItemID uuid.UUID
	}{
		Ctx:    ctx,
		ItemID: itemID,
	}
	mock.lockGetItem.Lock()
	mock.calls.GetItem = append(mock.calls.GetItem, callInfo)
	mock.lockGetItem.Unlock()
	return mock.GetItemFunc(ctx, itemID)
}

// GetItemCalls gets all the calls that were made to GetItem.
// Check the length with:
//
//	len(mockedinboxService.GetItemCalls())
func (mock *inboxServiceMock) GetItemCalls() []struct {
	Ctx    context.Context
	ItemID uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		ItemID uuid.UUID
	}
	mock.lockGetItem.RLock()
	calls = mock.calls.GetItem
	mock.lockGetItem.RUnlock()
	return calls
}

// ListItems calls ListItemsFunc.
func (mock *inboxServiceMock) ListItems(ctx context.Context, input inbox.ListItemsInput) ([]*domain.InboxItem, int, error) {
	if mock.ListItemsFunc == nil {
		panic("inboxServiceMock.ListItemsFunc: method is nil but inboxService.ListItems was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Input inbox.ListItemsInput
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockListItems.Lock()
	mock.calls.ListItems = append(mock.calls.ListItems, callInfo)
	mock.lockListItems.Unlock()
	return mock.ListItemsFunc(ctx, input)
}

// ListItemsCalls gets all the calls that were made to ListItems.
// Check the length with:
//
//	len(mockedinboxService.ListItemsCalls())
func (mock *inboxServiceMock) ListItemsCalls() []struct {
	Ctx   context.Context
	Input inbox.ListItemsInput
} {
	var calls []struct {
		Ctx   context.Context
		Input inbox.ListItemsInput
	}
	mock.lockListItems.RLock()
	calls = mock.calls.ListItems
	mock.lockListItems.RUnlock()
	return calls
}
