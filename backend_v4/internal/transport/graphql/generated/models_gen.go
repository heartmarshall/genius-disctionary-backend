// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"fmt"
	"io"
	"strconv"

	"github.com/google/uuid"
	"github.com/heartmarshall/myenglish-backend/internal/domain"
)

type AbandonSessionPayload struct {
	Success bool `json:"success"`
}

type AddExampleInput struct {
	SenseID     uuid.UUID `json:"senseId"`
	Sentence    string    `json:"sentence"`
	Translation *string   `json:"translation,omitempty"`
}

type AddExamplePayload struct {
	Example *domain.Example `json:"example"`
}

type AddSenseInput struct {
	EntryID      uuid.UUID            `json:"entryId"`
	Definition   *string              `json:"definition,omitempty"`
	PartOfSpeech *domain.PartOfSpeech `json:"partOfSpeech,omitempty"`
	CefrLevel    *string              `json:"cefrLevel,omitempty"`
	Translations []string             `json:"translations,omitempty"`
}

type AddSensePayload struct {
	Sense *domain.Sense `json:"sense"`
}

type AddTranslationInput struct {
	SenseID uuid.UUID `json:"senseId"`
	Text    string    `json:"text"`
}

type AddTranslationPayload struct {
	Translation *domain.Translation `json:"translation"`
}

type AddUserImageInput struct {
	EntryID uuid.UUID `json:"entryId"`
	URL     string    `json:"url"`
	Caption *string   `json:"caption,omitempty"`
}

type AddUserImagePayload struct {
	Image *domain.UserImage `json:"image"`
}

type AdminUsersResult struct {
	Users []*domain.User `json:"users"`
	Total int            `json:"total"`
}

type BatchCreateCardError struct {
	EntryID uuid.UUID `json:"entryId"`
	Message string    `json:"message"`
}

type BatchCreateCardsPayload struct {
	CreatedCount    int                     `json:"createdCount"`
	SkippedExisting int                     `json:"skippedExisting"`
	SkippedNoSenses int                     `json:"skippedNoSenses"`
	Errors          []*BatchCreateCardError `json:"errors"`
}

type BatchDeletePayload struct {
	DeletedCount int           `json:"deletedCount"`
	Errors       []*BatchError `json:"errors"`
}

type BatchError struct {
	ID      uuid.UUID `json:"id"`
	Message string    `json:"message"`
}

type BatchLinkEntriesInput struct {
	TopicID  uuid.UUID   `json:"topicId"`
	EntryIds []uuid.UUID `json:"entryIds"`
}

type BatchLinkPayload struct {
	Linked  int `json:"linked"`
	Skipped int `json:"skipped"`
}

type CardHistoryPayload struct {
	Logs       []*domain.ReviewLog `json:"logs"`
	TotalCount int                 `json:"totalCount"`
}

type CardSnapshotOutput struct {
	State         domain.CardState `json:"state"`
	Step          int              `json:"step"`
	Stability     float64          `json:"stability"`
	Difficulty    float64          `json:"difficulty"`
	ScheduledDays int              `json:"scheduledDays"`
}

type ClearInboxPayload struct {
	DeletedCount int `json:"deletedCount"`
}

type CreateCardPayload struct {
	Card *domain.Card `json:"card"`
}

type CreateEntryCustomInput struct {
	Text       string              `json:"text"`
	Senses     []*CustomSenseInput `json:"senses"`
	Notes      *string             `json:"notes,omitempty"`
	CreateCard *bool               `json:"createCard,omitempty"`
	TopicID    *uuid.UUID          `json:"topicId,omitempty"`
}

type CreateEntryFromCatalogInput struct {
	RefEntryID uuid.UUID   `json:"refEntryId"`
	SenseIds   []uuid.UUID `json:"senseIds"`
	Notes      *string     `json:"notes,omitempty"`
	CreateCard *bool       `json:"createCard,omitempty"`
}

type CreateEntryPayload struct {
	Entry *domain.Entry `json:"entry"`
}

type CreateInboxItemInput struct {
	Text    string  `json:"text"`
	Context *string `json:"context,omitempty"`
}

type CreateInboxItemPayload struct {
	Item *domain.InboxItem `json:"item"`
}

type CreateTopicInput struct {
	Name        string  `json:"name"`
	Description *string `json:"description,omitempty"`
}

type CreateTopicPayload struct {
	Topic *domain.Topic `json:"topic"`
}

type CustomExampleInput struct {
	Sentence    string  `json:"sentence"`
	Translation *string `json:"translation,omitempty"`
}

type CustomSenseInput struct {
	Definition   *string               `json:"definition,omitempty"`
	PartOfSpeech *domain.PartOfSpeech  `json:"partOfSpeech,omitempty"`
	Translations []string              `json:"translations,omitempty"`
	Examples     []*CustomExampleInput `json:"examples,omitempty"`
}

type DeleteCardPayload struct {
	CardID uuid.UUID `json:"cardId"`
}

type DeleteEntryPayload struct {
	EntryID uuid.UUID `json:"entryId"`
}

type DeleteExamplePayload struct {
	ExampleID uuid.UUID `json:"exampleId"`
}

type DeleteInboxItemPayload struct {
	ItemID uuid.UUID `json:"itemId"`
}

type DeleteSensePayload struct {
	SenseID uuid.UUID `json:"senseId"`
}

type DeleteTopicPayload struct {
	TopicID uuid.UUID `json:"topicId"`
}

type DeleteTranslationPayload struct {
	TranslationID uuid.UUID `json:"translationId"`
}

type DeleteUserImagePayload struct {
	ImageID uuid.UUID `json:"imageId"`
}

// Простой список с общим количеством (для offset-пагинации).
type DeletedEntriesList struct {
	Entries    []*domain.Entry `json:"entries"`
	TotalCount int             `json:"totalCount"`
}

type DictionaryConnection struct {
	Edges      []*DictionaryEdge `json:"edges"`
	PageInfo   *PageInfo         `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

type DictionaryEdge struct {
	Node   *domain.Entry `json:"node"`
	Cursor string        `json:"cursor"`
}

type DictionaryFilterInput struct {
	Search        *string              `json:"search,omitempty"`
	HasCard       *bool                `json:"hasCard,omitempty"`
	PartOfSpeech  *domain.PartOfSpeech `json:"partOfSpeech,omitempty"`
	TopicID       *uuid.UUID           `json:"topicId,omitempty"`
	Status        *domain.CardState    `json:"status,omitempty"`
	SortField     *EntrySortField      `json:"sortField,omitempty"`
	SortDirection *SortDirection       `json:"sortDirection,omitempty"`
	// Cursor-based: количество записей.
	First *int `json:"first,omitempty"`
	// Cursor-based: курсор после которого загружать.
	After *string `json:"after,omitempty"`
	// Offset-based: лимит записей.
	Limit *int `json:"limit,omitempty"`
	// Offset-based: смещение.
	Offset *int `json:"offset,omitempty"`
}

type FinishSessionPayload struct {
	Session *domain.StudySession `json:"session"`
}

type GetCardHistoryInput struct {
	CardID uuid.UUID `json:"cardId"`
	Limit  *int      `json:"limit,omitempty"`
	Offset *int      `json:"offset,omitempty"`
}

type ImportEntriesInput struct {
	Items []*ImportItemInput `json:"items"`
}

type ImportError struct {
	Index   int    `json:"index"`
	Text    string `json:"text"`
	Message string `json:"message"`
}

type ImportItemInput struct {
	Text         string   `json:"text"`
	Translations []string `json:"translations,omitempty"`
	Notes        *string  `json:"notes,omitempty"`
	TopicName    *string  `json:"topicName,omitempty"`
}

type ImportPayload struct {
	ImportedCount int            `json:"importedCount"`
	SkippedCount  int            `json:"skippedCount"`
	Errors        []*ImportError `json:"errors"`
}

type InboxItemList struct {
	Items      []*domain.InboxItem `json:"items"`
	TotalCount int                 `json:"totalCount"`
}

type LinkEntryInput struct {
	TopicID uuid.UUID `json:"topicId"`
	EntryID uuid.UUID `json:"entryId"`
}

type LinkEntryPayload struct {
	Success bool `json:"success"`
}

type Mutation struct {
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type Query struct {
}

type ReorderExamplesInput struct {
	SenseID uuid.UUID           `json:"senseId"`
	Items   []*ReorderItemInput `json:"items"`
}

type ReorderItemInput struct {
	ID       uuid.UUID `json:"id"`
	Position int       `json:"position"`
}

type ReorderPayload struct {
	Success bool `json:"success"`
}

type ReorderSensesInput struct {
	EntryID uuid.UUID           `json:"entryId"`
	Items   []*ReorderItemInput `json:"items"`
}

type ReorderTranslationsInput struct {
	SenseID uuid.UUID           `json:"senseId"`
	Items   []*ReorderItemInput `json:"items"`
}

type RestoreEntryPayload struct {
	Entry *domain.Entry `json:"entry"`
}

type ReviewCardInput struct {
	CardID     uuid.UUID          `json:"cardId"`
	Grade      domain.ReviewGrade `json:"grade"`
	DurationMs *int               `json:"durationMs,omitempty"`
}

type ReviewCardPayload struct {
	Card *domain.Card `json:"card"`
}

type StartSessionPayload struct {
	Session *domain.StudySession `json:"session"`
}

type UndoReviewPayload struct {
	Card *domain.Card `json:"card"`
}

type UnlinkEntryInput struct {
	TopicID uuid.UUID `json:"topicId"`
	EntryID uuid.UUID `json:"entryId"`
}

type UnlinkEntryPayload struct {
	Success bool `json:"success"`
}

type UpdateEntryNotesInput struct {
	EntryID uuid.UUID `json:"entryId"`
	Notes   *string   `json:"notes,omitempty"`
}

type UpdateEntryPayload struct {
	Entry *domain.Entry `json:"entry"`
}

type UpdateExampleInput struct {
	ExampleID   uuid.UUID `json:"exampleId"`
	Sentence    *string   `json:"sentence,omitempty"`
	Translation *string   `json:"translation,omitempty"`
}

type UpdateExamplePayload struct {
	Example *domain.Example `json:"example"`
}

type UpdateProfileInput struct {
	Name      string  `json:"name"`
	AvatarURL *string `json:"avatarUrl,omitempty"`
}

type UpdateProfilePayload struct {
	User *domain.User `json:"user"`
}

type UpdateSenseInput struct {
	SenseID      uuid.UUID            `json:"senseId"`
	Definition   *string              `json:"definition,omitempty"`
	PartOfSpeech *domain.PartOfSpeech `json:"partOfSpeech,omitempty"`
	CefrLevel    *string              `json:"cefrLevel,omitempty"`
}

type UpdateSensePayload struct {
	Sense *domain.Sense `json:"sense"`
}

type UpdateSettingsInput struct {
	NewCardsPerDay   *int     `json:"newCardsPerDay,omitempty"`
	ReviewsPerDay    *int     `json:"reviewsPerDay,omitempty"`
	MaxIntervalDays  *int     `json:"maxIntervalDays,omitempty"`
	DesiredRetention *float64 `json:"desiredRetention,omitempty"`
	Timezone         *string  `json:"timezone,omitempty"`
}

type UpdateSettingsPayload struct {
	Settings *domain.UserSettings `json:"settings"`
}

type UpdateTopicInput struct {
	TopicID     uuid.UUID `json:"topicId"`
	Name        *string   `json:"name,omitempty"`
	Description *string   `json:"description,omitempty"`
}

type UpdateTopicPayload struct {
	Topic *domain.Topic `json:"topic"`
}

type UpdateTranslationInput struct {
	TranslationID uuid.UUID `json:"translationId"`
	Text          string    `json:"text"`
}

type UpdateTranslationPayload struct {
	Translation *domain.Translation `json:"translation"`
}

type EntrySortField string

const (
	EntrySortFieldText      EntrySortField = "TEXT"
	EntrySortFieldCreatedAt EntrySortField = "CREATED_AT"
	EntrySortFieldUpdatedAt EntrySortField = "UPDATED_AT"
)

var AllEntrySortField = []EntrySortField{
	EntrySortFieldText,
	EntrySortFieldCreatedAt,
	EntrySortFieldUpdatedAt,
}

func (e EntrySortField) IsValid() bool {
	switch e {
	case EntrySortFieldText, EntrySortFieldCreatedAt, EntrySortFieldUpdatedAt:
		return true
	}
	return false
}

func (e EntrySortField) String() string {
	return string(e)
}

func (e *EntrySortField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntrySortField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntrySortField", str)
	}
	return nil
}

func (e EntrySortField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EntrySortField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EntrySortField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SortDirection string

const (
	SortDirectionAsc  SortDirection = "ASC"
	SortDirectionDesc SortDirection = "DESC"
)

var AllSortDirection = []SortDirection{
	SortDirectionAsc,
	SortDirectionDesc,
}

func (e SortDirection) IsValid() bool {
	switch e {
	case SortDirectionAsc, SortDirectionDesc:
		return true
	}
	return false
}

func (e SortDirection) String() string {
	return string(e)
}

func (e *SortDirection) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirection", str)
	}
	return nil
}

func (e SortDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SortDirection) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SortDirection) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
